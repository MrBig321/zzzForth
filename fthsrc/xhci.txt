( NOT Ready !!)
( XHCIENUM works, but as soon as I added the words related to XHCIDEVINFO, there is a memory problem)
( It seems that during boot the size of KRNL.SYS is too big !?) ( lxhci prints strange error messages) 
( Done with polling, not IRQ)


: XHCI ;   ( marker for FORGET)

( Abbreviations)
( A - add)
( AL - alloc)
( B - byte)
( C - calculate)
( CL - clear)
( CR - create)
( CP - copy)
( D - dword)
( E - enable)
( G - get)
( ? - returns flag)
( P - put)
( R - restore)
( S - set)
( SA - save)
( W - word)

: KEY? KEYW DISCARD DROP ;  ( for testing)

( **********USB/COMMON**********)
HEX

( Controller Types)
00 CONSTANT USBTYPEUHCI
10 CONSTANT USBTYPEOHCI
20 CONSTANT USBTYPEEHCI
30 CONSTANT USBTYPEXHCI

DECIMAL 

: 3DUP  ( a b c -- a b c a b c )  DUP 2OVER ROT ;
: 3DROP DROP 2DROP ;

( transfer types [Endpoint types] [USB 2.0 page 270])
0 CONSTANT USBCONTROLEP
1 CONSTANT USBISOCHRONOUSEP
2 CONSTANT USBBULKEP
3 CONSTANT USBINTERRUPTEP

( Reset wait times.  USB 2.0 specs, page 153, section 7.1.7.5, paragraph 3)
50 CONSTANT USBTDRSTR  ( reset on a root hub)
10 CONSTANT USBTDRST   ( minimum delay for a reset)
 3 CONSTANT USBTRHRSI  ( No more than this between resets for root hubs)
10 CONSTANT USBTRSTRCY ( reset recovery)

18 CONSTANT XHCIDEVDESCSIZE 
22 CONSTANT XHCIBOSDESCSIZE 
64 CONSTANT XHCICONFIGDESCSIZE 

( Device Descriptor offsets)
 0 CONSTANT USBDEVDESCLEN       ( bit8u  len)
 1 CONSTANT USBDEVDESCTYPE      ( bit8u  type)
 2 CONSTANT USBDEVDESCVER       ( bit16u usb_ver)
 4 CONSTANT USBDEVDESCCLASS     ( bit8u  _class)
 5 CONSTANT USBDEVDESCSUBCLASS  ( bit8u  subclass)
 6 CONSTANT USBDEVDESCPROTOCOL  ( bit8u  protocol)
 7 CONSTANT USBDEVDESCMAXPACKETSIZE ( bit8u  max_packet_size)
 8 CONSTANT USBDEVDESCVENDORID  ( bit16u vendorid)
10 CONSTANT USBDEVDESCPRODUCTID ( bit16u productid)
12 CONSTANT USBDEVDESCDEVICEREL ( bit16u device_rel)
14 CONSTANT USBDEVDESCMANUFIDX  ( bit8u  manuf_indx ; index value)
15 CONSTANT USBDEVDESCPRODIDX   ( bit8u  prod_indx ; index value)
16 CONSTANT USBDEVDESCSERIALIDX ( bit8u  serial_indx ; index value)
17 CONSTANT USBDEVDESCCONFIGS   ( bit8u  configs ; Number of configurations)

DECIMAL

( Request Packet offsets)
0 CONSTANT USBRECPACTYPE     ( bit8u  request_type)
1 CONSTANT USBRECPACREQUEST  ( bit8u  request)
2 CONSTANT USBRECPACVALUE    ( bit16u value)
4 CONSTANT USBRECPACIDX      ( bit16u index)
6 CONSTANT USBRECPACLENGTH   ( bit16u length)

8 CONSTANT USBREQUESTPACKETSIZE

( struct REQUEST_PACKET)
(	bit8u  request_type;)
(	bit8u  request;)
(	bit16u value;)
(	bit16u index;)
(	bit16u length;)

HEX

( setup packets)
080 CONSTANT USBDEVTOHOST
 00 CONSTANT USBHOSTTODEV
 00 CONSTANT USBREQTYPESTNDRD
020 CONSTANT USBREQTYPECLASS
040 CONSTANT USBREQTYPEVENDOR
060 CONSTANT USBREQTYPERESV
 00 CONSTANT USBRECPTDEVICE
 01 CONSTANT USBRECPTINTERFACE
 02 CONSTANT USBRECPTENDPOINT
 03 CONSTANT USBRECPTOTHER
USBDEVTOHOST USBREQTYPESTNDRD USBRECPTDEVICE OR OR CONSTANT USBSTDRDGETREQUEST 
USBHOSTTODEV USBREQTYPESTNDRD USBRECPTDEVICE OR OR CONSTANT USBSTDRDSETREQUEST 
USBHOSTTODEV USBREQTYPESTNDRD USBRECPTINTERFACE OR OR CONSTANT USBSTDRDSETINTERFACE 

DECIMAL 

( device requests)
 0 CONSTANT USBDEVREQGETSTATUS
 1 CONSTANT USBDEVREQCLEARFEATURE
 3 CONSTANT USBDEVREQSETFEATURE
 5 CONSTANT USBDEVREQSETADDRESS
 6 CONSTANT USBDEVREQGETDESCRIPTOR
 7 CONSTANT USBDEVREQSETDESCRIPTOR
 8 CONSTANT USBDEVREQGETCONFIGURATION
 9 CONSTANT USBDEVREQSETCONFIGURATION
( interface requests)
10 CONSTANT USBDEVREQGETINTERFACE
11 CONSTANT USBDEVREQSETINTERFACE
( standard endpoint requests)
12 CONSTANT USBDEVREQSYNCHFRAME
HEX
( Device specific)
0FE CONSTANT USBDEVREQGETMAXLUNS	
0FF CONSTANT USBDEVREQBULKONLYRESET

DECIMAL

( Descriptor types)
 1 CONSTANT USBDESCTYPDEVICE
 2 CONSTANT USBDESCTYPCONFIG
 3 CONSTANT USBDESCTYPSTRING
 4 CONSTANT USBDESCTYPINTERFACE
 5 CONSTANT USBDESCTYPENDPOINT
 6 CONSTANT USBDESCTYPDEVICEQUALIFIER
 7 CONSTANT USBDESCTYPOTHERSPEEDCONFIG
 8 CONSTANT USBDESCTYPINTERFACEPOWER
 9 CONSTANT USBDESCTYPOTG
10 CONSTANT USBDESCTYPDEBUG
11 CONSTANT USBDESCTYPINTERFACEASSOCIATION
HEX
021 CONSTANT USBDESCTYPHID
022 CONSTANT USBDESCTYPHIDREPORT
023 CONSTANT USBDESCTYPHIDPHYSICAL
029 CONSTANT USBDESCTYPHUB	

0F CONSTANT USBDESCTYPBOS

DECIMAL 

 8 CONSTANT USBCBWTOTALBYTESOFFS
15 CONSTANT USBCBWCOMMANDOFFS

  0 CONSTANT USBSUCCESS  
 -1 CONSTANT USBERRORSTALLED
 -2 CONSTANT USBERRORDATABUFFERERROR
 -3 CONSTANT USBERRORBABBLEDETECTED
 -4 CONSTANT USBERRORNAK
254 CONSTANT USBERRORTIMEOUT
255 CONSTANT USBERRORUNKNOWN

HEX

0500 CONSTANT DEVDESCBUFF  ( from FORTH Memory map !?)

( device descriptor request)
DEVDESCBUFF 20 + CONSTANT REQDEVDESCPACKET
REQDEVDESCPACKET USBREQUESTPACKETSIZE ERASE
USBSTDRDGETREQUEST REQDEVDESCPACKET USBRECPACTYPE + C!
USBDEVREQGETDESCRIPTOR REQDEVDESCPACKET USBRECPACREQUEST + C!
USBDESCTYPDEVICE 8 LSHIFT REQDEVDESCPACKET USBRECPACVALUE + W!

REQDEVDESCPACKET 10 + CONSTANT REQSTRLANGSPACKET
REQSTRLANGSPACKET USBREQUESTPACKETSIZE ERASE
080  REQSTRLANGSPACKET USBRECPACTYPE + C!
06   REQSTRLANGSPACKET USBRECPACREQUEST + C!
0300 REQSTRLANGSPACKET USBRECPACVALUE + W!

REQSTRLANGSPACKET 10 + CONSTANT REQCONFIGPACKET
REQCONFIGPACKET USBREQUESTPACKETSIZE ERASE
080  REQCONFIGPACKET USBRECPACTYPE + C!
06   REQCONFIGPACKET USBRECPACREQUEST + C!
0200 REQCONFIGPACKET USBRECPACVALUE + W!

REQCONFIGPACKET 10 + CONSTANT REQLUNPACKET
REQLUNPACKET USBREQUESTPACKETSIZE ERASE
0A1  REQLUNPACKET USBRECPACTYPE + C!
0FE  REQLUNPACKET USBRECPACREQUEST + C!
01   REQLUNPACKET USBRECPACLENGTH + W!

REQLUNPACKET 10 + CONSTANT REQSCONFIGPACKET
REQSCONFIGPACKET USBREQUESTPACKETSIZE ERASE
09 REQSCONFIGPACKET USBRECPACREQUEST + C!
01 REQSCONFIGPACKET USBRECPACVALUE + W!

REQSCONFIGPACKET 10 + CONSTANT REQBOSPACKET
REQBOSPACKET USBREQUESTPACKETSIZE ERASE
080 REQBOSPACKET USBRECPACTYPE + C!
06  REQBOSPACKET USBRECPACREQUEST + C!
0F  REQBOSPACKET USBRECPACVALUE + W!

REQBOSPACKET 10 + CONSTANT REQBULKRESETPACKET
REQBULKRESETPACKET USBREQUESTPACKETSIZE ERASE
021 REQBULKRESETPACKET USBRECPACTYPE + C!
0FF REQBULKRESETPACKET USBRECPACREQUEST + C!

REQBULKRESETPACKET 10 + CONSTANT REQBULKENDPTRESETPACKET
REQBULKENDPTRESETPACKET USBREQUESTPACKETSIZE ERASE
02 REQBULKENDPTRESETPACKET USBRECPACTYPE + C!
01 REQBULKENDPTRESETPACKET USBRECPACREQUEST + C!

( **********USB/COMMON END**********)


( **********USB/SCSI**********)
REQSTRLANGSPACKET 10 + CONSTANT SCSITESTUNITCBW
SCSITESTUNITCBW 31 ERASE
HEX
043425355 SCSITESTUNITCBW ! 
0AABBCCDD SCSITESTUNITCBW CELL+ ! 
6 SCSITESTUNITCBW 0E + C! 
( scsi_testunit_cbw	dd 0x43425355	;dCBWSignature)
(					dd 0xAABBCCDD	;dCBWTag)
(					dd 0			;dCBWDataTransferLength)
(					db 0			;bmCBWFlags 0x80=Device2Host, 00=Host2Device)
(					db 0			;bCBWLun)
(					db 6			;bCBWCBLength )
(					db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 )

DECIMAL
SCSITESTUNITCBW 32 + CONSTANT SCSISENSECBW
SCSISENSECBW 31 ERASE
HEX
043425355 SCSISENSECBW ! 
0BBAADDCC SCSISENSECBW CELL+ ! 
012 SCSISENSECBW 2 CELLS + ! 
080 SCSISENSECBW 3 CELLS + C! 
 06 SCSISENSECBW 0E + C! 
 03 SCSISENSECBW 0F + C! 
012 SCSISENSECBW 13 + C! 
( scsi_sense_cbw		dd 0x43425355   ;dCBWSignature)
(					dd 0xBBAADDCC   ;dCBWTag)
(					dd 0x00000012	;dCBWDataTransferLength)
(					db 0x80			;bmCBWFlags 0x80=Device2Host, 00=Host2Device)
(					db 0x00			;bCBWLun)
(					db 0x06			;bCBWCBLength )
(					db 0x03, 0x00, 0x00, 0x00, 0x12, 0x00, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 )

DECIMAL
SCSISENSECBW 32 + CONSTANT SCSIINQUIRYCBW
SCSIINQUIRYCBW 31 ERASE
HEX
043425355 SCSIINQUIRYCBW ! 
0AAFFBBFF SCSIINQUIRYCBW CELL+ ! 
024 SCSIINQUIRYCBW 2 CELLS + ! 
080 SCSIINQUIRYCBW 3 CELLS + C! 
 06 SCSIINQUIRYCBW 0E + C! 
012 SCSIINQUIRYCBW 0F + C! 
024 SCSIINQUIRYCBW 13 + C! 
( scsi_inquiry_cbw		dd	0x43425355		; Signature, 		'USBC')
(						dd	0xAAFFBBFF		; Tag, 				arbitrary, will be returned in CSW)
(						dd	0x00000024		; Transfer Length,	we want at most 36 bytes returned)
(						db	0x80			; Flags,			receive an in packet)
(						db	0x00			; LUN, 				first volume)
(						db	0x06			; Command Len,		this command is 6 bytes)
(						db	0x12, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 )

DECIMAL
SCSIINQUIRYCBW 32 + CONSTANT SCSIREADCAPACITY10CBW
SCSIREADCAPACITY10CBW 31 ERASE
HEX
043425355 SCSIREADCAPACITY10CBW ! 
0CCFFDDFF SCSIREADCAPACITY10CBW CELL+ ! 
 08 SCSIREADCAPACITY10CBW 2 CELLS + ! 
080 SCSIREADCAPACITY10CBW 3 CELLS + C! 
 0A SCSIREADCAPACITY10CBW 0E + C! 
025 SCSIREADCAPACITY10CBW 0F + C! 
( scsi_read_capacity10_cbw	dd	0x43425355		; Signature, 		'USBC')
(							dd	0xCCFFDDFF		; Tag, 				arbitrary, will be returned in CSW)
(							dd	0x00000008		; Transfer Length,	we want at most 8 bytes returned)
(							db	0x80			; Flags,			receive an in packet)
(							db	0x00			; LUN, 				first volume)
(							db	0x0A			; Command Len,		this command is 10 bytes)
(							db	0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 )

DECIMAL
SCSIREADCAPACITY10CBW 32 + CONSTANT SCSIREADCAPACITY16CBW
SCSIREADCAPACITY16CBW 31 ERASE
HEX
043425355 SCSIREADCAPACITY16CBW ! 
0EEAADDBB SCSIREADCAPACITY16CBW CELL+ ! 
020 SCSIREADCAPACITY16CBW 2 CELLS + ! 
080 SCSIREADCAPACITY16CBW 3 CELLS + C! 
010 SCSIREADCAPACITY16CBW 0E + C! 
09E SCSIREADCAPACITY16CBW 0F + C! 
010 SCSIREADCAPACITY16CBW 10 + C! 
( scsi_read_capacity16_cbw	dd	0x43425355		; Signature, 		'USBC')
(							dd	0xEEAADDBB		; Tag, 				arbitrary, will be returned in CSW)
(							dd	0x00000020		; Transfer Length,	we want at most 32 bytes returned)
(							db	0x80			; Flags,			receive an in packet)
(							db	0x00			; LUN, 				first volume)
(							db	0x10			; Command Len,		this command is 16 bytes)
(							db	0x9E, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 )

DECIMAL
SCSIREADCAPACITY16CBW 32 + CONSTANT SCSIREAD10CBW
SCSIREAD10CBW 31 ERASE
HEX
043425355 SCSIREAD10CBW ! 
0DD88EE77 SCSIREAD10CBW CELL+ ! 
080 SCSIREAD10CBW 3 CELLS + C! 
 0A SCSIREAD10CBW 0E + C! 
028 SCSIREAD10CBW 0F + C! 
( scsi_read10_cbw		dd	0x43425355		; Signature, 		'USBC')
(					dd	0xDD88EE77		; Tag, 				arbitrary, will be returned in CSW)
(					dd	0x00000000		; Transfer Length,	#sector * sectorsize, 				TO FILL)
(					db	0x80			; Flags,			receive an in packet)
(					db	0x00			; LUN, 				first volume)
(					db	0x0A			; Command Len,		this command is 10 bytes)
(					db	0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  )
(						; 3,4,5,6 LBA; 8,9 is #ofblocks  FILL )

DECIMAL
SCSIREAD10CBW 32 + CONSTANT SCSIREAD12CBW
SCSIREAD12CBW 31 ERASE
HEX
043425355 SCSIREAD12CBW ! 
0BBAA7733 SCSIREAD12CBW CELL+ ! 
080 SCSIREAD12CBW 3 CELLS + C! 
 0C SCSIREAD12CBW 0E + C! 
0A8 SCSIREAD12CBW 0F + C! 
( scsi_read12_cbw		dd	0x43425355		; Signature, 		'USBC')
(					dd	0xBBAA7733		; Tag, 				arbitrary, will be returned in CSW)
(					dd	0x00000000		; Transfer Length,	#sector * sectorsize,				 TO FILL)
(					db	0x80			; Flags,			receive an in packet)
(					db	0x00			; LUN, 				first volume)
(					db	0x0C			; Command Len,		this command is 12 bytes)
(					db	0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 )
(						; 3,4,5,6 LBA; 7,8,9,10 is #ofblocks   FILL )

DECIMAL
SCSIREAD12CBW 32 + CONSTANT SCSIREAD16CBW
SCSIREAD16CBW 31 ERASE
HEX
043425355 SCSIREAD16CBW ! 
0BB2255CC SCSIREAD16CBW CELL+ ! 
080 SCSIREAD16CBW 3 CELLS + C! 
 10 SCSIREAD16CBW 0E + C! 
088 SCSIREAD16CBW 0F + C! 
( scsi_read16_cbw		dd	0x43425355		; Signature, 		'USBC')
(					dd	0xBB2255CC		; Tag, 				arbitrary, will be returned in CSW)
(					dd	0x00000000		; Transfer Length,	#sector * sectorsize,				 TO FILL)
(					db	0x80			; Flags,			receive an in packet)
(					db	0x00			; LUN, 				first volume)
(					db	0x10			; Command Len,		this command is 16 bytes)
(					db	0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 )
(						; 3-10 LBA; 11,12,13,14 is #ofblocks  FILL )

DECIMAL
SCSIREAD16CBW 32 + CONSTANT SCSIWRITE10CBW
SCSIWRITE10CBW 31 ERASE
HEX
043425355 SCSIWRITE10CBW ! 
033557799 SCSIWRITE10CBW CELL+ ! 
 0A SCSIWRITE10CBW 0E + C! 
02A SCSIWRITE10CBW 0F + C! 
( scsi_write10_cbw	dd	0x43425355		; Signature, 		'USBC')
(					dd	0x33557799		; Tag, 				arbitrary, will be returned in CSW)
(					dd	0x00000000		; Transfer Length,	#sector * sectorsize, 				TO FILL)
(					db	0x00			; Flags,			send an out packet)
(					db	0x00			; LUN, 				first volume)
(					db	0x0A			; Command Len,		this command is 10 bytes)
(					db	0x2A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  )
(						; 3,4,5,6 LBA; 8,9 is #ofblocks   FILL )

DECIMAL
SCSIWRITE10CBW 32 + CONSTANT SCSIWRITE12CBW
SCSIWRITE12CBW 31 ERASE
HEX
043425355 SCSIWRITE12CBW ! 
0BBAA7733 SCSIWRITE12CBW CELL+ ! 
 0C SCSIWRITE12CBW 0E + C! 
0AA SCSIWRITE12CBW 0F + C! 
( scsi_write12_cbw	dd	0x43425355		; Signature, 		'USBC')
(					dd	0xBBAA7733		; Tag, 				arbitrary, will be returned in CSW)
(					dd	0x00000000		; Transfer Length,	#sector * sectorsize,				 TO FILL)
(					db	0x00			; Flags,			send an out packet)
(					db	0x00			; LUN, 				first volume)
(					db	0x0C			; Command Len,		this command is 12 bytes)
(					db	0xAA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 )
(						; 3,4,5,6 LBA; 7,8,9,10 is #ofblocks   FILL )

DECIMAL
SCSIWRITE12CBW 32 + CONSTANT SCSIWRITE16CBW
SCSIWRITE16CBW 31 ERASE
HEX
043425355 SCSIWRITE16CBW ! 
011223344 SCSIWRITE16CBW CELL+ ! 
 10 SCSIWRITE16CBW 0E + C! 
08A SCSIWRITE16CBW 0F + C! 
( scsi_write16_cbw	dd	0x43425355		; Signature, 		'USBC')
(					dd	0x11223344		; Tag, 				arbitrary, will be returned in CSW)
(					dd	0x00000000		; Transfer Length,	#sector * sectorsize,				 TO FILL)
(					db	0x00			; Flags,			send an out packet)
(					db	0x00			; LUN, 				first volume)
(					db	0x10			; Command Len,		this command is 16 bytes)
(					db	0x8A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 )
(						; 3-10 LBA; 11,12,13,14 is #ofblocks    FILL )

( **********USB/SCSI END**********)

DECIMAL

HEX
( from FORTH-Memory-Map[FMM] in forth/forth.asm)
900000 CONSTANT XHCIHEAPINIT   
800000 CONSTANT XHCIHEAPSIZE 
DECIMAL
XHCIHEAPINIT XHCIHEAPSIZE + CONSTANT XHCIHEAPLIMIT 

4096 CONSTANT XHCIMAXTRBCNTPERTRRING 
30 CONSTANT XHCIMAXSEGMENTCNTPERTRRING 

CREATE XHCITRRINGSEGMENTS XHCIMAXSEGMENTCNTPERTRRING CELLS ALLOT 
CREATE XHCITRRINGSEGMENTCNTS XHCIMAXSEGMENTCNTPERTRRING CELLS ALLOT 

1024 CONSTANT XHCICMNDRINGTRBS 
1024 CONSTANT XHCITRBSPERRING 
4096 CONSTANT XHCITRBSPEREVENTRING	    ( currently only one segment is created in xhci_create_event_ring, so this is the maximum)
4096 28 * CONSTANT XHCITRBSPERBULKRING	( we can read at least a 45Mb file with this; see also XHCIHEAPSIZE)

HEX
9000 CONSTANT XHCIBUFF  ( from FORTH Memory map !?)

00 CONSTANT XHCICAPSCAPLENGTH 
01 CONSTANT XHCICAPSRESERVED 
02 CONSTANT XHCICAPSIVERSION 
04 CONSTANT XHCICAPSHCSPARAMS1 
08 CONSTANT XHCICAPSHCSPARAMS2 
0C CONSTANT XHCICAPSHCSPARAMS3 
10 CONSTANT XHCICAPSHCCPARAMS1 
14 CONSTANT XHCICAPSDBOFF 
18 CONSTANT XHCICAPSRTSOFF 
1C CONSTANT XHCICAPSHCCPARAMS2	

00 CONSTANT XHCIOPSUSBCOMMAND 
04 CONSTANT XHCIOPSUSBSTATUS 
08 CONSTANT XHCIOPSUSBPAGESIZE 
14 CONSTANT XHCIOPSUSBDNCTRL 
18 CONSTANT XHCIOPSUSBCRCR 
30 CONSTANT XHCIOPSUSBDCBAAP 
38 CONSTANT XHCIOPSUSBCONFIG 

400 CONSTANT XHCIOPSUSBPORTST 
DECIMAL
 0 CONSTANT XHCIPORTPORTSC 
 4 CONSTANT XHCIPORTPORTPMSC 
 8 CONSTANT XHCIPORTPORTLI 
12 CONSTANT XHCIPORTRESV 

( Quirk:  TI TUSB7340: sets bit 19 on USB2 ports  ??????????????)
1 17 LSHIFT 1 18 LSHIFT 1 20 LSHIFT 1 21 LSHIFT 1 22 LSHIFT OR OR OR OR CONSTANT XHCIPORTUSBCHANGEBITS

0 CONSTANT XHCIINTERRUPTERPRIMARY 

HEX
00 CONSTANT XHCIINTERRUPTERIMAN 
04 CONSTANT XHCIINTERRUPTERIMOD 
08 CONSTANT XHCIINTERRUPTERTABSIZE 
0C CONSTANT XHCIINTERRUPTERRESV 
10 CONSTANT XHCIINTERRUPTERADDRESS 
18 CONSTANT XHCIINTERRUPTERDEQUEUE 

DECIMAL
( XHCI speed values)
1 CONSTANT XHCISPEEDFULL 
2 CONSTANT XHCISPEEDLOW 
3 CONSTANT XHCISPEEDHIGH
4 CONSTANT XHCISPEEDSUPER 

0 CONSTANT XHCIDIRNODATA 
2 CONSTANT XHCIDIROUT 
3 CONSTANT XHCIDIRIN 

0 CONSTANT XHCIDIROUTB 
1 CONSTANT XHCIDIRINB 

( End Point Doorbell numbers) 
 0 CONSTANT XHCISLOTCNTX 
 1 CONSTANT XHCICONTROLEP 
 2 CONSTANT XHCIEP1OUT 
 3 CONSTANT XHCIEP1IN 
 4 CONSTANT XHCIEP2OUT 
 5 CONSTANT XHCIEP2IN 
 6 CONSTANT XHCIEP3OUT 
 7 CONSTANT XHCIEP3IN 
 8 CONSTANT XHCIEP4OUT 
 9 CONSTANT XHCIEP4IN 
10 CONSTANT XHCIEP5OUT 
11 CONSTANT XHCIEP5IN 
12 CONSTANT XHCIEP6OUT 
13 CONSTANT XHCIEP6IN 
14 CONSTANT XHCIEP7OUT 
15 CONSTANT XHCIEP7IN 
16 CONSTANT XHCIEP8OUT 
17 CONSTANT XHCIEP8IN 
18 CONSTANT XHCIEP9OUT 
19 CONSTANT XHCIEP9IN 
20 CONSTANT XHCIEP10OUT 
21 CONSTANT XHCIEP10IN 
22 CONSTANT XHCIEP11OUT 
23 CONSTANT XHCIEP11IN 
24 CONSTANT XHCIEP12OUT 
25 CONSTANT XHCIEP12IN 
26 CONSTANT XHCIEP13OUT 
27 CONSTANT XHCIEP13IN 
28 CONSTANT XHCIEP14OUT 
29 CONSTANT XHCIEP14IN 
30 CONSTANT XHCIEP15OUT 
31 CONSTANT XHCIEP15IN 

( Port_info flags)
1          CONSTANT XHCIPROTOINFO     ( bit 0 set = USB3, else USB2)
1 1 LSHIFT CONSTANT XHCIPROTOHSO      ( bit 1 set = is USB 2 and High Speed Only)
1 2 LSHIFT CONSTANT XHCIPROTOHASPAIR  ( bit 2 set = has a corresponding port. [i.e.: is a USB3 and has USB2 port [a must]])
                                      (     clear = does not have a corr. port [i.e.: is a USB2 port and does not have a USB3 port])
1 3 LSHIFT CONSTANT XHCIPROTOACTIVE   ( is the active port of the pair.)

0 CONSTANT XHCIPROTOUSB2 
1 CONSTANT XHCIPROTOUSB3 

6 CONSTANT XHCITRBIDLINK 
8 CONSTANT XHCITRBIDNOOP 

 0 CONSTANT XHCIXECPIDNONE 
 1 CONSTANT XHCIXECPIDLEGACY 
 2 CONSTANT XHCIXECPIDPROTO 
 3 CONSTANT XHCIXECPIDPOWER 
 4 CONSTANT XHCIXECPIDVIRT 
 5 CONSTANT XHCIXECPIDMESS 
 6 CONSTANT XHCIXECPIDLOCAL 
10 CONSTANT XHCIXECPIDDEBUG 
17 CONSTANT XHCIXECPIDEXTMESS 

10 CONSTANT XHCIXECPLEGACYTIMEOUT                ( 10 milliseconds)
1 16 LSHIFT CONSTANT XHCIXECPLEGACYBIOSOWNED 
1 24 LSHIFT CONSTANT XHCIXECPLEGACYOSOWNED 
XHCIXECPLEGACYBIOSOWNED XHCIXECPLEGACYOSOWNED OR CONSTANT XHCIXECPLEGACYOWNEDMASK  

64 CONSTANT XHCIMAXCTXSIZE                    ( Max Context size in bytes)
XHCIMAXCTXSIZE 32 * CONSTANT XHCIMAXSLOTSIZE  ( Max Total Slot size in bytes)

( Slot State)
0 CONSTANT XHCISLOTSTATEDISABLEDENABLED 
1 CONSTANT XHCISLOTSTATEDEFAULT 
2 CONSTANT XHCISLOTSTATEADDRESSED 
3 CONSTANT XHCISLOTSTATECONFIGURED 

( EndPoint Types)
0 CONSTANT XHCIEPTYPENOTVALID
1 CONSTANT XHCIEPTYPEISOCHROUT
2 CONSTANT XHCIEPTYPEBULKOUT
3 CONSTANT XHCIEPTYPEINTERROUT
4 CONSTANT XHCIEPTYPECONTROL
5 CONSTANT XHCIEPTYPEISOCHRIN
6 CONSTANT XHCIEPTYPEBULKIN
7 CONSTANT XHCIEPTYPEINTERRIN

 0 CONSTANT XHCISLOTCTXENTRIESOFFS 
 4 CONSTANT XHCISLOTCTXHUBOFFS
 5 CONSTANT XHCISLOTCTXMTTOFFS
 6 CONSTANT XHCISLOTCTXSPEEDOFFS 
10 CONSTANT XHCISLOTCTXROUTESTROFFS
14 CONSTANT XHCISLOTCTXNUMPORTSOFFS
18 CONSTANT XHCISLOTCTXRHPORTNUMOFFS
22 CONSTANT XHCISLOTCTXMAXEXITLATOFFS
26 CONSTANT XHCISLOTCTXINTTARGETOFFS
30 CONSTANT XHCISLOTCTXTTTOFFS
34 CONSTANT XHCISLOTCTXTTPORTNUMOFFS
38 CONSTANT XHCISLOTCTXTTHUBSLOTIDOFFS
42 CONSTANT XHCISLOTCTXSLOTSTATEOFFS
46 CONSTANT XHCISLOTCTXDEVICEADDROFFS

( EP State)
0 CONSTANT XHCIEPSTATEDISABLED 
1 CONSTANT XHCIEPSTATERUNNING 
2 CONSTANT XHCIEPSTATEHALTED
3 CONSTANT XHCIEPSTATESTOPPED
4 CONSTANT XHCIEPSTATEERROR 

 0 CONSTANT XHCIEPCTXINTERVALOFFS
 4 CONSTANT XHCIEPCTXLSAOFFS
 5 CONSTANT XHCIEPCTXMAXPSTREAMSOFFS
 9 CONSTANT XHCIEPCTXMULTOFFS
13 CONSTANT XHCIEPCTXEPSTATEOFFS
17 CONSTANT XHCIEPCTXMAXPACKETSIZEOFFS
21 CONSTANT XHCIEPCTXMAXBURSTSIZEOFFS
25 CONSTANT XHCIEPCTXHIDOFFS
26 CONSTANT XHCIEPCTXEPTYPEOFFS
30 CONSTANT XHCIEPCTXCERROFFS
34 CONSTANT XHCIEPCTXTRDEQUEUEPTRLOOFFS
38 CONSTANT XHCIEPCTXTRDEQUEUEPTRHIOFFS
42 CONSTANT XHCIEPCTXDCSOFFS
43 CONSTANT XHCIEPCTXMAXESITPAYLOADOFFS
47 CONSTANT XHCIEPCTXMAXAVERAGETRBLENOFFS

16 CONSTANT XHCITRBSIZE	
( TRB-struct)
 0 CONSTANT XHCITRBPARAMOFFS
 8 CONSTANT XHCITRBSTATUSOFFS
12 CONSTANT XHCITRBCOMMANDOFFS

0 CONSTANT XHCIDIREPOUT 
1 CONSTANT XHCIDIREPIN 

HEX
0700 CONSTANT XHCITRBBUFF       ( from FORTH Memory map !?)
0720 CONSTANT XHCIEVENTTRBBUFF  ( from FORTH Memory map !?)
0740 CONSTANT XHCIEVENTORGTRBBUFF  ( from FORTH Memory map !?)
0760 CONSTANT XHCISLOTCTXBUFF   ( from FORTH Memory map !?) ( 50 bytes!?)
07A0 CONSTANT XHCIEPCTXBUFF     ( from FORTH Memory map !?) ( 51 bytes!?)
07E0 CONSTANT XHCISLOTCTXBUFF2   ( from FORTH Memory map !?) ( 50 bytes!?)
0820 CONSTANT XHCIEPCTXBUFF2     ( from FORTH Memory map !?) ( 51 bytes!?)
DECIMAL
50 CONSTANT XHCISLOTCTXSIZE
51 CONSTANT XHCIEPCTXSIZE

( Not used)
: XHCIGETDIR  ( n1 -- n2 )
   1 7 LSHIFT AND 7 RSHIFT ;

( Not used)
: XHCITRBGETSTYPE  ( n1 -- n2 )
   [ HEX ] 01F [ DECIMAL ] 16 LSHIFT AND 16 RSHIFT ;

: XHCITRBSETSTYPE  ( n1 -- n2 )
   [ HEX ] 01F [ DECIMAL ] AND 16 LSHIFT ;

: XHCITRBGETTYPE  ( n1 -- n2 )
   [ HEX ] 03F [ DECIMAL ] 10 LSHIFT AND 10 RSHIFT ;

: XHCITRBSETTYPE  ( n1 -- n2 )
   [ HEX ] 03F [ DECIMAL ] AND 10 LSHIFT ;

: XHCITRBGETCOMPCODE  ( n1 -- n2 )
   [ HEX ] 07F [ DECIMAL ] 24 LSHIFT AND 24 RSHIFT ;

( Not used)
: XHCITRBSETCOMPCODE  ( n1 -- n2 )
   [ HEX ] 07F [ DECIMAL ] AND 24 LSHIFT ;

: XHCITRBGETSLOT  ( n1 -- n2 )
   [ HEX ] 0FF [ DECIMAL ] 24 LSHIFT AND 24 RSHIFT ;

: XHCITRBSETSLOT  ( n1 -- n2 )
   [ HEX ] 0FF [ DECIMAL ] AND 24 LSHIFT ;

( Not used)
: XHCITRBGETTDSIZE  ( n1 -- n2 )
   [ HEX ] 01F [ DECIMAL ] 17 LSHIFT AND 17 RSHIFT ;

( Not used)
: XHCITRBSETTDSIZE  ( n1 -- n2 )
   [ HEX ] 01F [ DECIMAL ] AND 17 LSHIFT ;

( Not used)
: XHCITRBGETEP  ( n1 -- n2 )
   [ HEX ] 01F [ DECIMAL ] 16 LSHIFT AND 16 RSHIFT ;

( Not used)
: XHCITRBSETEP  ( n1 -- n2 )
   [ HEX ] 01F [ DECIMAL ] AND 16 LSHIFT ;

( Not used)
: XHCITRBGETTARGET  ( n1 -- n2 )
   [ HEX ] 03FF [ DECIMAL ] 22 LSHIFT AND 22 RSHIFT ;

( Not used)
: XHCITRBGETTXLEN  ( n1 -- n2 )
   [ HEX ] 01FFFF [ DECIMAL ] AND ;

( Not used)
: XHCITRBGETTOGGLE  ( n1 -- n2 )
   [ HEX ] 01 [ DECIMAL ] 1 LSHIFT AND 1 RSHIFT ;

( Not used)
: XHCITRBDC  ( n1 -- n2 )
   [ HEX ] 01 [ DECIMAL ] 9 LSHIFT AND 9 RSHIFT ;

( Not used)
: XHCITRBISIMMEDDATA  ( n1 -- n2 )
   [ HEX ] 01 [ DECIMAL ] 6 LSHIFT AND 6 RSHIFT ;

( Not used)
: XHCITRBIOC  ( n1 -- n2 )
   [ HEX ] 01 [ DECIMAL ] 5 LSHIFT AND 5 RSHIFT ;

( Not used)
: XHCITRBCHAIN  ( n1 -- n2 )
   [ HEX ] 01 [ DECIMAL ] 4 LSHIFT AND 4 RSHIFT ;

( Not used)
: XHCITRBSPD  ( n1 -- n2 )
   [ HEX ] 01 [ DECIMAL ] 2 LSHIFT AND 2 RSHIFT ;

1 CONSTANT XHCITRBCYCLEON
0 CONSTANT XHCITRBCYCLEOFF

1 1 LSHIFT CONSTANT XHCITRBTOGGLECYCLEON
0 1 LSHIFT CONSTANT XHCITRBTOGGLECYCLEOFF  ( !?)

1 4 LSHIFT CONSTANT XHCITRBCHAINON
0 4 LSHIFT CONSTANT XHCITRBCHAINOFF        ( !?)

1 5 LSHIFT CONSTANT XHCITRBIOCON
0 5 LSHIFT CONSTANT XHCITRBIOCOFF          ( !?)

( Common TRB types)
 1 CONSTANT XHCINORMAL	
 2 CONSTANT XHCISTPSTAGE
 3 CONSTANT XHCIDTSTAGE
 4 CONSTANT XHCISTSSTAGE
 5 CONSTANT XHCIISOCH
 6 CONSTANT XHCILINK
 7 CONSTANT XHCIEVENTDATA
 8 CONSTANT XHCINOOP
 9 CONSTANT XHCIENABLESLOT
10 CONSTANT XHCIDISABLESLOT
11 CONSTANT XHCIADDRESSDEVICE
12 CONSTANT XHCICONFIGEP
13 CONSTANT XHCIEVALUATECTX
14 CONSTANT XHCIRESETEP
15 CONSTANT XHCISTOPEP
16 CONSTANT XHCISETTRDEQUEUE
17 CONSTANT XHCIRESETDEVICE
18 CONSTANT XHCIFORCEEVENT
19 CONSTANT XHCIDEGBANDWIDTH
20 CONSTANT XHCISETLATTOLERANCE
21 CONSTANT XHCIGETPORTBAND
22 CONSTANT XHCIFORCEHEADER
23 CONSTANT XHCINOOPCMD
( 24 - 31 = reserved)
32 CONSTANT XHCITRANSEVENT
33 CONSTANT XHCICOMMANDCOMPLETION	
34 CONSTANT XHCIPORTSTATUSCHANGE
35 CONSTANT XHCIBANDWIDTHREQUEST
36 CONSTANT XHCIDOORBELLEVENT
37 CONSTANT XHCIHOSTCONTROLLEREVENT
38 CONSTANT XHCIDEVICENOTIFICATION
39 CONSTANT XHCIMFINDEXWRAP
( 40 - 47 = reserved)
( 48 - 63 = Vendor Defined)

( TToggleCyleOff | On !? and several are zeros! TRBCYCLEON !? ) 
XHCILINK XHCITRBSETTYPE XHCITRBIOCOFF XHCITRBCHAINOFF XHCITRBTOGGLECYCLEOFF XHCITRBCYCLEON OR OR OR OR CONSTANT XHCITRBLINKCMND

( event completion codes)
 1 CONSTANT XHCITRBSUCCESS
 2 CONSTANT XHCIDATABUFFERERROR
 3 CONSTANT XHCIBABBLEDETECTION
 4 CONSTANT XHCITRANSACTIONERROR
 5 CONSTANT XHCITRBERROR
 6 CONSTANT XHCISTALLERROR
 7 CONSTANT XHCIRESOURCEERROR
 8 CONSTANT XHCIBANDWIDTHERROR
 9 CONSTANT XHCINOSLOTSERROR
10 CONSTANT XHCIINVALIDSTREAMTYPE
11 CONSTANT XHCISLOTNOTENABLED
12 CONSTANT XHCIEPNOTENABLED
13 CONSTANT XHCISHORTPACKET
14 CONSTANT XHCIRINGUNDERRUN
15 CONSTANT XHCIRINGOVERRUN
16 CONSTANT XHCIVFEVENTRINGFULL
17 CONSTANT XHCIPARAMETERERROR
18 CONSTANT XHCIBANDWITDHOVERRUN
19 CONSTANT XHCICTXSTATEERROR
20 CONSTANT XHCINOPINGRESPONSE
21 CONSTANT XHCIEVENTRINGFULL
22 CONSTANT XHCIINCOMPATIBLEDEVICE
23 CONSTANT XHCIMISSEDSERVICE
24 CONSTANT XHCICOMMANDRINGSTOPPED
25 CONSTANT XHCICOMMANDABORTED
26 CONSTANT XHCISTOPPED
27 CONSTANT XHCISTOPPERLENGTHERROR
28 CONSTANT XHCIRESERVED
29 CONSTANT XHCIISOCHBUFFEROVERRUN  ( !?)
32 CONSTANT XHCIEVERNLOST
33 CONSTANT XHCIUNDEFINED
34 CONSTANT XHCIINVALIDSTREAMID
35 CONSTANT XHCISECONDARYBANDWIDTH
36 CONSTANT XHCISPLITTRANSACTION
( 37 - 191 reserved)
( 192 - 223 vender defined errors)
( 224 - 225 vendor defined info)

1 31 LSHIFT CONSTANT XHCIRESPDONE 

31 CONSTANT XHCICBWLEN 
13 CONSTANT XHCICSWLEN

0 CONSTANT XHCIDEVICESMALL
1 CONSTANT XHCIDEVICEMEDIUM
2 CONSTANT XHCIDEVICEBIG

32 CONSTANT XHCIMAXDEVCNT          ( this could be 127, but I belive, we won't use that many devices knowing that currently no external HUBs are supported)

( portinfo)
0 CONSTANT XHCIPIFLAGSOFFS
1 CONSTANT XHCIPIOTHERPNOFFS
2 CONSTANT XHCIPIOFFSETOFFS
3 CONSTANT XHCIPIRESERVEDOFFS
 4 CONSTANT XHCIPISIZE        ( in bytes)
32 CONSTANT XHCIMAXPINUM      ( arbitrary)
CREATE XHCIPI XHCIMAXPINUM XHCIPISIZE * ALLOT

: XHCIPICL  ( -- )
   XHCIPI XHCIMAXPINUM XHCIPISIZE * ERASE ;

: XHCIPIIDX  ( idx -- addr )
   2 LSHIFT XHCIPI + ;

: XHCIISUSB3PORT  ( n -- flag )
   XHCIPIIDX XHCIPIFLAGSOFFS + C@ XHCIPROTOINFO AND XHCIPROTOUSB3 = ;
   
: XHCIISUSB2PORT  ( n -- flag )
   XHCIPIIDX XHCIPIFLAGSOFFS + C@ XHCIPROTOINFO AND XHCIPROTOUSB2 = ;

: XHCIISUSB2HSO  ( n -- flag )
   XHCIPIIDX XHCIPIFLAGSOFFS + C@ XHCIPROTOHSO AND XHCIPROTOHSO = ;

: XHCIHASPAIR  ( n -- flag )
   XHCIPIIDX XHCIPIFLAGSOFFS + C@ XHCIPROTOHASPAIR AND XHCIPROTOHASPAIR = ;

: XHCIISACTIVE  ( n -- flag )
   XHCIPIIDX XHCIPIFLAGSOFFS + C@ XHCIPROTOACTIVE AND XHCIPROTOACTIVE = ;

32 CONSTANT XHCIMAXDEVCNT   ( could be 127, but external HUBs are supported)

CREATE XHCICUREPRINGPTRARR XHCIMAXDEVCNT CELLS ALLOT
CREATE XHCICUREPRINGCYCLEARR XHCIMAXDEVCNT ALLOT

: XHCICLCUREPRINGPTRARR  ( -- )
   XHCICUREPRINGPTRARR XHCIMAXDEVCNT CELLS ERASE 
   XHCICUREPRINGCYCLEARR XHCIMAXDEVCNT ERASE ;

VARIABLE XHCICUREPRINGPTR
VARIABLE XHCICUREPRINGCYCLE	

: XHCISACUREPRINGPTR  ( slotID -- )
   1- DUP XHCIMAXDEVCNT U>= IF DROP EXIT THEN 
   DUP >R 2 LSHIFT XHCICUREPRINGPTRARR + XHCICUREPRINGPTR @ SWAP ! 
   R> XHCICUREPRINGCYCLEARR + XHCICUREPRINGCYCLE @ SWAP C! ;

: XHCIGCUREPRINGPTR  ( slotID -- )
   1- DUP XHCIMAXDEVCNT U>= IF DROP EXIT THEN 
   DUP >R 2 LSHIFT XHCICUREPRINGPTRARR + @ XHCICUREPRINGPTR ! 
   R> XHCICUREPRINGCYCLEARR + C@ XHCICUREPRINGCYCLE ! ;

VARIABLE XHCICURHEAPPTR	
VARIABLE XHCICURHEAPPTRSAVED	
XHCIHEAPINIT XHCICURHEAPPTR !
VARIABLE XHCICURHEAPPTRAFTERENUM	
VARIABLE XHCICURHEAPPTRSAVED 
VARIABLE XHCIINITEDMSD
HEX 0FF DECIMAL XHCIINITEDMSD !

HEX
 04 CONSTANT PCICOMMAND      ( word)
010 CONSTANT PCIBAR0         ( DWORD)
014 CONSTANT PCIBAR1         ( DWORD)
DECIMAL

VARIABLE XHCIBASE4BITS 
VARIABLE XHCIBASE0

VARIABLE XHCIOPBASEOFF 

: XHCIEBUSMASTER  ( b d f -- )
   PCICOMMAND 6 PCICFGWRW ;

: XHCIGBASE  ( b d f -- )
   PCIBAR0 PCICFGRDD DUP 
   [ HEX ] 0F [ DECIMAL ] AND XHCIBASE4BITS ! 
   [ HEX ] 0F INVERT [ DECIMAL ] AND XHCIBASE0 ! ;

: XHCIFLADJ   ( b d f -- )
   [ HEX ] 061 020 [ DECIMAL ] PCICFGWRB ;

: XHCIGVER?  ( -- flag )
   XHCIBASE0 @ XHCICAPSIVERSION + W@ [ HEX ] 095 [ DECIMAL ] U< ; 

: XHCIGUP32BITS  ( b d f -- n )
   PCIBAR1 PCICFGRDD ;

: XHCIPANTHERPOINT  ( b d f -- )
   3DUP 0 PCICFGRDW [ HEX ] 08086 [ DECIMAL ] = 
   IF 
      3DUP 2 PCICFGRDW [ HEX ] 01E31 [ DECIMAL ] =
      IF 
        3DUP 8 PCICFGRDB 4 = 
        IF 
          3DUP [ HEX ] 0D8 FFFFFFFF [ DECIMAL ] PCICFGWRD  
               [ HEX ] 0D0 FFFFFFFF [ DECIMAL ] PCICFGWRD  
        THEN
      THEN 
   THEN 3DROP ;

: XHCICBASEOFF  ( -- )
   XHCIBASE0 @ XHCICAPSCAPLENGTH + C@ XHCIOPBASEOFF ! ;

: XHCIRESETCTRL?  ( -- flag )
   XHCIBASE0 @ XHCIOPBASEOFF @ + XHCIOPSUSBCOMMAND + DUP 2 SWAP ! 
   TRUE SWAP 500 0 DO DUP @ 2 AND 0= IF NIP FALSE SWAP LEAVE THEN 1 SLEEP LOOP DROP ;

VARIABLE XHCIHCCPARAMS1 
VARIABLE XHCIHCCPARAMS2 
VARIABLE XHCIHCSPARAMS1 
VARIABLE XHCIHCSPARAMS2 
VARIABLE XHCIRTSOFF
VARIABLE XHCIDBOFF
VARIABLE XHCIEXTCAPSOFF 
VARIABLE XHCICTXSIZE 

: XHCICEXTCAPSREGS  ( -- )
   XHCIBASE0 @ XHCICAPSHCCPARAMS1 + @ XHCIHCCPARAMS1 !
   XHCIBASE0 @ XHCICAPSHCCPARAMS2 + @ XHCIHCCPARAMS2 !
   XHCIBASE0 @ XHCICAPSHCSPARAMS1 + @ XHCIHCSPARAMS1 !
   XHCIBASE0 @ XHCICAPSHCSPARAMS2 + @ XHCIHCSPARAMS2 !
   XHCIBASE0 @ XHCICAPSRTSOFF + @ [ HEX ] 01F INVERT AND [ DECIMAL ] XHCIRTSOFF !
   XHCIBASE0 @ XHCICAPSDBOFF + @ [ HEX ] 03 INVERT AND [ DECIMAL ] XHCIDBOFF !
   XHCIHCCPARAMS1 @ [ HEX ] FFFF0000 [ DECIMAL ] AND 16 RSHIFT 2 LSHIFT XHCIEXTCAPSOFF ! 
   XHCIHCCPARAMS1 @ 4 AND 0= IF 32 ELSE 64 THEN XHCICTXSIZE ! ;

: XHCIFINDLEGACY  ( -- addr TRUE )   ( -- FALSE )
   XHCIBASE0 @ XHCIEXTCAPSOFF @ + 
   BEGIN
     DUP C@ XHCIXECPIDLEGACY = 
     IF TRUE EXIT THEN  
     DUP @ 8 RSHIFT [ HEX ] 0FF [ DECIMAL ] AND DUP 0= 
     IF CR ." No legacy support" CR 2DROP FALSE EXIT THEN 
     2 LSHIFT +
   AGAIN ;

: XHCISTOPLEGACY  ( -- flag )  ( TRUE on success)
   XHCIFINDLEGACY ( addr flag )
   IF DUP DUP @ XHCIXECPLEGACYOSOWNED OR SWAP ! 
     XHCIXECPLEGACYTIMEOUT 0 
     DO
       DUP @ XHCIXECPLEGACYOWNEDMASK AND XHCIXECPLEGACYOSOWNED = 
       IF DROP TRUE UNLOOP EXIT THEN 
       1 SLEEP
     LOOP 
     DROP FALSE
   ELSE TRUE 
   THEN ;

VARIABLE XHCINDP   ( number of downstream ports)

VARIABLE XHCIPORTSUSB2
VARIABLE XHCIPORTSUSB3

: XHCIGPROTOOFFSET  ( listoff version -- next flags offset count )
   >R 
   BEGIN
     DUP DUP XHCIBASE0 @ + 1+ C@ DUP 0<> ( listoff listoff item_next flag )
     IF 2 LSHIFT +           ( listoff next )
     ELSE 2DROP 0            ( listoff next[0] )
     THEN
     OVER XHCIBASE0 @ + DUP C@ XHCIXECPIDPROTO = SWAP 3 + C@ R@ = AND 
     IF   ( listoff next )  ( R: version )
       R> DROP SWAP XHCIBASE0 @ + DUP >R 10 + W@ [ HEX ] 0FFF [ DECIMAL ] AND   ( next flags ) ( R: base+listoff )
       R@ 8 + C@ 1- ( next flags offset ) ( R: base+listoff )
       R> 9 + C@        ( next flags offset count )
       EXIT       
     THEN
     NIP
   DUP 0= UNTIL 
   R> DROP 0 0 0 ;

: XHCIGPORTCNT   ( -- )
   XHCIHCSPARAMS1 @ [ HEX ] FF000000 [ DECIMAL ] AND 24 RSHIFT XHCINDP ! ;

( find the USB 2.0 ports and mark the port_info byte as USB2 if found)
: XHCIFINDUSB2PORTS   ( -- )
   XHCIEXTCAPSOFF @ DUP 0<>
   IF        ( next )
     BEGIN
       2 XHCIGPROTOOFFSET ( next flags offset count ) 
       DUP 0<>
       IF 
         0 DO    ( next flags offset )
             DUP I + XHCIPIIDX DUP ( next flags offset PI[4*[offset+i]] PI[4*[offset+i]] )
             XHCIPIOFFSETOFFS + XHCIPORTSUSB2 @ SWAP C!
             1 XHCIPORTSUSB2 +!
             DUP XHCIPIFLAGSOFFS + XHCIPROTOUSB2 SWAP C!
          ( next flags offset PI[4*[offset+i]] )
             >R OVER 2 AND R> SWAP 
             IF XHCIPIFLAGSOFFS + DUP C@ XHCIPROTOHSO OR SWAP C! 
             ELSE DROP 
             THEN
           LOOP
           2DROP
       ELSE 3DROP
       THEN  ( next )
       DUP 0=
     UNTIL 
   THEN
   DROP ;

( find the USB 3.0 ports and mark the port_info byte as USB3 if found)
: XHCIFINDUSB3PORTS   ( -- )
   XHCIEXTCAPSOFF @ DUP 0<>
   IF        ( next )
     BEGIN
       3 XHCIGPROTOOFFSET ( next flags offset count ) 
       DUP 0<>
       IF 
         0 DO    ( next flags offset )
             DUP I + XHCIPIIDX DUP ( next flags offset PI[4*[offset+i]] PI[4*[offset+i]] )
             XHCIPIOFFSETOFFS + XHCIPORTSUSB3 @ SWAP C!
             1 XHCIPORTSUSB3 +!
             XHCIPIFLAGSOFFS + XHCIPROTOUSB3 SWAP C!
           LOOP
           2DROP 
       ELSE 3DROP
       THEN  ( next )
       DUP 0=
     UNTIL 
   THEN
   DROP ;

( pair up each USB3 port with it's companion USB2 port)
: XHCIPAIRUPUSB2USB3  ( -- )
   XHCINDP @ 0 
   DO 
     XHCINDP @ 0 
     DO 
       I XHCIPIIDX XHCIPIOFFSETOFFS + C@ J XHCIPIIDX XHCIPIOFFSETOFFS + C@ = 
       I XHCIPIIDX XHCIPIFLAGSOFFS + C@ XHCIPROTOINFO AND J XHCIPIIDX XHCIPIFLAGSOFFS + C@ XHCIPROTOINFO AND <> AND 
       IF 
         I J XHCIPIIDX XHCIPIOTHERPNOFFS + C!
         J XHCIPIIDX XHCIPIFLAGSOFFS + DUP C@ XHCIPROTOHASPAIR OR SWAP C!
         J I XHCIPIIDX XHCIPIOTHERPNOFFS + C!
         I XHCIPIIDX XHCIPIFLAGSOFFS + DUP C@ XHCIPROTOHASPAIR OR SWAP C!
       THEN 
     LOOP 
   LOOP ;

( mark all USB3 ports and any USB2 only ports as active, deactivating any USB2 ports that have a USB3 companion)
: XHCIMARKPORTS  ( -- )
   XHCINDP @ 0 
   DO 
     I XHCIISUSB3PORT I XHCIISUSB2PORT I XHCIHASPAIR INVERT AND OR 
     IF 
       I XHCIPIIDX XHCIPIFLAGSOFFS + DUP C@ XHCIPROTOACTIVE OR SWAP C! 
     THEN 
   LOOP ;

VARIABLE XHCIPAGESIZE
VARIABLE XHCIMAXSLOTS 
VARIABLE XHCIDCBAAPSTART 

( get the page size of the controller)
: XHCIGPAGESIZE  ( -- )
   XHCIBASE0 @ XHCIOPBASEOFF @ + XHCIOPSUSBPAGESIZE + @ [ HEX ] 0FFFF [ DECIMAL ] AND 12 LSHIFT XHCIPAGESIZE ! ;

: XHCIGMAXSLOTS   ( -- )
   XHCIHCSPARAMS1 @ [ HEX ] 0FF [ DECIMAL ] AND XHCIMAXSLOTS ! ;

: XHCIALHEAP   ( size alignment boundary -- memaddr )
   SWAP 1- DUP XHCICURHEAPPTR @ + SWAP INVERT AND XHCICURHEAPPTR !
   SWAP 3 + 3 INVERT AND  ( boundary size )
   SWAP DUP 0>
   IF 
     DUP 1- XHCICURHEAPPTR @ + OVER 1- INVERT AND  ( size boundary NextBoundary )
     >R 2DUP    ( size boundary size boundary )  ( R: NextBoundary )
     SWAP XHCICURHEAPPTR @ + SWAP > R> SWAP ( size boundary NextBdry flag )
     IF XHCICURHEAPPTR ! ELSE DROP THEN 
   THEN
   ( size boundary )
   >R DUP XHCICURHEAPPTR @ + 1- XHCIHEAPLIMIT U>= OVER R@ 0> SWAP R> U> AND OR
   ABORT" Error in allocating memory within our heap! "
   ( size )
   XHCICURHEAPPTR @ OVER ERASE 
   XHCICURHEAPPTR @ SWAP XHCICURHEAPPTR +! ;

: XHCIALDCBAAPSTART  ( -- )
   2048 64 XHCIPAGESIZE @ XHCIALHEAP XHCIDCBAAPSTART ! ;

: XHCIDOHI32  ( addr -- addr+CELL )
   CELL+ XHCIHCCPARAMS1 @ 1 AND 0<> IF DUP 0 SWAP ! THEN ;

: XHCISOPSUSBDCBAAP  ( -- )
   XHCIBASE0 @ XHCIOPBASEOFF @ + XHCIOPSUSBDCBAAP + XHCIDCBAAPSTART @ OVER ! XHCIDOHI32 DROP ;

: XHCIALSCRATCHPAD   ( -- )
    XHCIHCSPARAMS2 @ [ HEX ] F8000000 [ DECIMAL ] AND 27 RSHIFT ( maxscrpbuffs )
    DUP 0> 
    IF DUP DUP 3 LSHIFT 64 XHCIPAGESIZE @ XHCIALHEAP              ( maxscrpbuffs maxscrpbuffs scrpbuffarrstart )
      SWAP XHCIPAGESIZE @ * XHCIPAGESIZE @ 0 XHCIALHEAP           ( maxscrpbuffs scrpbuffarrstart scrpbuffstart )
      OVER XHCIDCBAAPSTART @ ! XHCIDCBAAPSTART @ XHCIDOHI32 DROP  ( maxscrpbuffs scrpbuffarrstart scrpbuffstart )
      ROT                 ( scrpbuffarrstart scrpbuffstart maxscrpbuffs )
      0 DO                ( scrpbuffarrstart scrpbuffstart )
          2DUP I XHCIPAGESIZE @ * + SWAP I 3 LSHIFT + DUP >R ! R> XHCIDOHI32 DROP 
        LOOP DROP
    THEN DROP ;

( Not used)
: XHCICLSEGS  ( -- )
   XHCITRRINGSEGMENTS XHCIMAXSEGMENTCNTPERTRRING CELLS ERASE 
   XHCITRRINGSEGMENTCNTS XHCIMAXSEGMENTCNTPERTRRING CELLS ERASE ;

VARIABLE IVAR

: XHCIALRINGSEGS  ( n -- )
( CR ." IVAR=" IVAR @ U. KEY? )
   DUP 4 LSHIFT 64 65536 XHCIALHEAP XHCITRRINGSEGMENTS IVAR @ 2 LSHIFT DUP >R + ! XHCITRRINGSEGMENTCNTS R> + ! 
( CR ." Seg[0]=" XHCITRRINGSEGMENTS HEX @ U. DECIMAL KEY? )
;

: XHCISETLINKTRBS  ( n -- )
   0 DO XHCITRRINGSEGMENTS I 2 LSHIFT + @ XHCITRRINGSEGMENTCNTS I 2 LSHIFT + @   ( ptrToSeg #TRBs ) 
        1- 4 LSHIFT + ( ptrToLastTRBInSeg )
        I 1+ 2 LSHIFT XHCITRRINGSEGMENTS + @ ( ptrToLastTRBInseg ptrToNextSeg )
         OVER ! XHCIDOHI32 
        ( status)   ( ptrToLastTRBInSeg+CELL )
        CELL+ DUP 0 SWAP ! CELL+ XHCITRBLINKCMND SWAP ! 
     LOOP ;

: XHCISETLASTLINKTRB  ( n -- )
   1- 2 LSHIFT DUP >R XHCITRRINGSEGMENTS + @ R> XHCITRRINGSEGMENTCNTS + @ 1- 4 LSHIFT + ( ptrToLastTRBInSeg )
   XHCITRRINGSEGMENTS @ OVER ! XHCIDOHI32                                               ( ptrToLastTRBInSeg+CELL )
   CELL+ DUP 0 SWAP ! CELL+ XHCITRBLINKCMND XHCITRBTOGGLECYCLEON OR SWAP ! ;

( *********Testing***********)
( : XHCIPRSEGS)  ( n -- )
(   DUP 0> IF HEX 0 DO XHCITRRINGSEGMENTS I 2 LSHIFT + @ U. LOOP DECIMAL ELSE DROP THEN ;)
( : XHCIPRSEGCNTS)  ( n -- )
(   DUP 0> IF DECIMAL 0 DO XHCITRRINGSEGMENTCNTS I 2 LSHIFT + @ U. LOOP ELSE DROP THEN ;)
( : XHCIPRLINKS)  ( segcnt -- )
(   HEX 0 DO XHCITRRINGSEGMENTS I 2 LSHIFT + @) ( ptrSeg ) 
(   XHCITRRINGSEGMENTCNTS I 2 LSHIFT + @) ( cntTRBS ) 
(   1- 4 LSHIFT +) ( ptrToLastTRB ) 
(   @ U. LOOP DECIMAL ;)
( : XHCIPRLINKTRBS)  ( segcnt -- )
(   HEX 0 DO XHCITRRINGSEGMENTS I 2 LSHIFT + @) ( ptrSeg ) 
(   XHCITRRINGSEGMENTCNTS I 2 LSHIFT + @) ( cntTRBS ) 
(   1- 4 LSHIFT +) ( ptrToLastTRB ) 
(   DUP @ CR ." paramLo=" U. CELL+ DUP @ ." paramHi=" U. CELL+ DUP @ ." status=" U. CELL+ @ ." cmd=" U. LOOP DECIMAL ;)

: XHCICRRING  ( n -- memaddr )
   XHCIMAXTRBCNTPERTRRING /MOD    ( rem quot )
   2DUP SWAP 0> IF 1+ THEN         ( rem quot quot|+1 )
   XHCIMAXSEGMENTCNTPERTRRING U> IF DROP XHCIMAXSEGMENTCNTPERTRRING OVER 0<> IF 1- THEN THEN 
   ( rem quot ) 
   SWAP OVER 0>  ( quot rem flag ) 
   IF OVER 0 DO I IVAR ! XHCIMAXTRBCNTPERTRRING XHCIALRINGSEGS LOOP THEN
   ( quot rem )
   DUP 0> IF OVER IVAR ! DUP XHCIALRINGSEGS THEN 
   0> IF 1+ THEN       ( segcnt )
   DUP 0= IF DROP EXIT THEN 
   DUP 1 > IF DUP 1- XHCISETLINKTRBS THEN
   XHCISETLASTLINKTRB XHCITRRINGSEGMENTS @ ;

: XHCICREVENTRING  ( n -- tableaddr addr )
   64 64 0 XHCIALHEAP                 ( n tableaddr )
   OVER 4 LSHIFT 64 65536 XHCIALHEAP  ( n tableaddr addr )
   2DUP SWAP ! SWAP DUP >R XHCIDOHI32   ( n addr tableaddr+CELL ) ( R: tableaddr )
   SWAP ROT ROT   ( addr n tableaddr+CELL )
   CELL+ DUP >R ! R> CELL+ 0 SWAP ! R> SWAP ;

VARIABLE XHCICMNDRINGADDR
VARIABLE XHCICMNDTRBADDR 
VARIABLE XHCICMNDTRBCYCLE 
VARIABLE XHCICUREVENTRINGADDR 
VARIABLE XHCIEVENTRINGTABLEADDR 
VARIABLE XHCICUREVENTRINGCYCLE 

: XHCICRCMDRING  ( -- )
   XHCICMNDRINGTRBS XHCICRRING DUP XHCICMNDRINGADDR ! XHCICMNDTRBADDR ! 
   XHCITRBCYCLEON XHCICMNDTRBCYCLE ! ;

: XHCIINITITERRUPTERS  ( -- )
   ( 1 XHCIHCSPARAMS2 @ [ HEX ] 0F0 [ DECIMAL ] AND 4 RSHIFT LSHIFT XHCIMAXEVENTSEGS !) ( not used!)
   ( XHCIHCSPARAMS1 @ [ HEX ] 07FF00 [ DECIMAL ] AND 8 RSHIFT XHCIMAXINTERRUPTERS !)    ( not used!)
   4096 XHCICREVENTRING XHCICUREVENTRINGADDR ! XHCIEVENTRINGTABLEADDR ! 
   1 XHCICUREVENTRINGCYCLE !
   XHCIBASE0 @ XHCIRTSOFF @ + [ HEX ] 020 [ DECIMAL ] + 
  ( IMAN: 31:2 ResvdP)
   DUP XHCIINTERRUPTERIMAN + DUP @ [ HEX ] FFFFFFFC [ DECIMAL ] AND 1 OR SWAP ! 
   0 OVER XHCIINTERRUPTERIMOD + !
  ( EVENTRINGSEGTABLESIZE: 31:16 ResvdP)
   DUP XHCIINTERRUPTERTABSIZE + DUP @ [ HEX ] FFFF0000 [ DECIMAL ] AND 1 OR SWAP ! 
   XHCICUREVENTRINGADDR @ 8 OR OVER XHCIINTERRUPTERDEQUEUE + !
   DUP XHCIINTERRUPTERDEQUEUE + XHCIDOHI32 DROP 
  ( EVENTRINGSEGTABLEADDR: 5:0 ResvdP)
   DUP XHCIINTERRUPTERADDRESS + DUP @ [ HEX ] 01F [ DECIMAL ] AND XHCIEVENTRINGTABLEADDR @ OR SWAP ! 
   XHCIINTERRUPTERADDRESS + XHCIDOHI32 DROP ;

: XHCIINITUSBCRCR  ( -- )
   XHCIBASE0 @ XHCIOPBASEOFF @ + XHCIOPSUSBCRCR + XHCICMNDRINGADDR @ XHCITRBCYCLEON OR OVER ! XHCIDOHI32 DROP ;

: XHCIINITUSBCFG  ( -- )
   XHCIMAXSLOTS @ XHCIBASE0 @ XHCIOPBASEOFF @ + XHCIOPSUSBCONFIG + ! ;

: XHCIINITUSBDNCRTL  ( -- )
   2 XHCIBASE0 @ XHCIOPBASEOFF @ + XHCIOPSUSBDNCTRL + ! ;

: XHCIDOPORTS  ( -- )
   XHCIGPORTCNT ." Found (virtual) root hub ports: " XHCINDP @ .  
   XHCINDP @ XHCIMAXPINUM U>= ABORT" Root-hub port-num >= allocated port_num array" CR 
   0 XHCIPORTSUSB2 ! 0 XHCIPORTSUSB3 ! XHCIFINDUSB2PORTS XHCIFINDUSB3PORTS XHCIPAIRUPUSB2USB3 XHCIMARKPORTS ; 

: XHCICLSTATUS  ( -- )
   1 10 LSHIFT 1 4 LSHIFT 1 3 LSHIFT 1 2 LSHIFT OR OR OR XHCIBASE0 @ XHCIOPBASEOFF @ + XHCIOPSUSBSTATUS + ! ;

: XHCISTARTSCHEDULE  ( -- )
   1 2 LSHIFT 1 OR XHCIBASE0 @ XHCIOPBASEOFF @ + XHCIOPSUSBCOMMAND + ! ;

: XHCICLPORTSTATUS  ( portscAddr -- )
   1 9 LSHIFT XHCIPORTUSBCHANGEBITS OR SWAP ! ;

: XHCIRESPORTU2U3  ( portscAddr port -- )
   XHCIISUSB3PORT 1 9 LSHIFT SWAP 
   IF 1 31 LSHIFT OR SWAP ! 
   ELSE 1 4 LSHIFT OR SWAP ! 
   THEN ;

: XHCIWAITBIT21  ( portscAddr -- flag )
   FALSE 500 0 DO OVER @ 1 21 LSHIFT AND 0<> IF DROP TRUE LEAVE THEN 1 SLEEP LOOP NIP ; 

: XHCIDOTO  ( portscAddr TOFlag -- retFlag )
   IF USBTRHRSI SLEEP DUP @ 2 AND 0<> 
    IF 1 9 LSHIFT XHCIPORTUSBCHANGEBITS OR SWAP ! TRUE 
    ELSE DROP FALSE
    THEN 
   ELSE DROP FALSE 
   THEN ;

: XHCIUSB2PORTACT   ( port retFlag -- )
   OVER XHCIISUSB2PORT AND 
   IF XHCIPIIDX DUP XHCIPIFLAGSOFFS + DUP DUP 
      C@ XHCIPROTOACTIVE OR SWAP C! 
      C@ XHCIPROTOHASPAIR AND 0<> 
      IF XHCIPIOTHERPNOFFS + C@ XHCIPIIDX XHCIPIFLAGSOFFS + 
         DUP C@ XHCIPROTOACTIVE INVERT AND SWAP C! 
      ELSE DROP
      THEN 
   ELSE DROP
   THEN ;

: XHCIUSB3PORTACT   ( port retFlag -- )
   INVERT OVER XHCIISUSB3PORT AND 
   IF XHCIPIIDX DUP XHCIPIFLAGSOFFS + DUP C@  
      XHCIPROTOACTIVE INVERT AND SWAP C!
      XHCIPIOTHERPNOFFS + C@ XHCIPIIDX XHCIPIFLAGSOFFS + 
      DUP C@ XHCIPROTOACTIVE OR SWAP C! 
   ELSE DROP
   THEN ;

: XHCICPORTST  ( port -- addr )
   4 LSHIFT XHCIBASE0 @ XHCIOPBASEOFF @ + + XHCIOPSUSBPORTST + ; 

: XHCIRESETPORT  ( port -- flag )
   DUP XHCICPORTST XHCIPORTPORTSC + DUP @ 1 9 LSHIFT AND 0=
  ( port portsc flag )
   IF 1 9 LSHIFT OVER ! 20 SLEEP DUP @ 1 9 LSHIFT AND 0= 
     IF 2DROP FALSE EXIT THEN 
   THEN    ( port portsc )
   DUP XHCICLPORTSTATUS 2DUP SWAP XHCIRESPORTU2U3 ( port portsc )
   DUP XHCIWAITBIT21       ( port portsc TOflag ) 
   XHCIDOTO                ( port retFlag ) 
   2DUP XHCIUSB2PORTACT SWAP OVER XHCIUSB3PORTACT ;

: XHCICLDEVDESC  ( -- )
   DEVDESCBUFF XHCIDEVDESCSIZE ERASE ; 

: XHCIGSPEED  ( portstAddr -- speed )
   XHCIPORTPORTSC + @ [ HEX ] 0F [ DECIMAL ] 10 LSHIFT AND 10 RSHIFT ;

: XHCISTRB   ( cmd status paramHI paramLO addrTRB -- )
   SWAP OVER ! CELL+ SWAP OVER ! CELL+ SWAP OVER ! CELL+ ! ;

VARIABLE XHCIORGTRBADDR 

: XHCICPTRB  ( from to -- )
(   XHCITRBSIZE CMOVE ;) ( !!!Must write param and status fields before cmd)
   OVER XHCITRBPARAMOFFS + @ OVER XHCITRBPARAMOFFS + !
   OVER XHCITRBPARAMOFFS + CELL+ @ OVER XHCITRBPARAMOFFS + CELL+ !
   OVER XHCITRBSTATUSOFFS + @ OVER XHCITRBSTATUSOFFS + !
   SWAP XHCITRBCOMMANDOFFS + @ SWAP XHCITRBCOMMANDOFFS + ! ;

: XHCIACMDTRB   ( trbAddr -- )
   XHCICMNDTRBADDR @ XHCICPTRB  
   XHCICMNDTRBADDR @ XHCITRBCOMMANDOFFS + XHCICMNDTRBCYCLE @ OVER @ OR SWAP !
   XHCITRBSIZE XHCICMNDTRBADDR +! ;

: XHCICHKCMDLINKTRB  ( -- )
   XHCICMNDTRBADDR @ XHCITRBCOMMANDOFFS + DUP @ DUP XHCITRBGETTYPE XHCILINK = 
  ( cmdoffsAddr cmd flag )
  IF SWAP OVER 1 INVERT AND XHCICMNDTRBCYCLE @ OR SWAP ! ( cmd )
     XHCICMNDTRBADDR @ @ XHCICMNDTRBADDR !
     2 AND 0<>
     IF XHCICMNDTRBCYCLE @ 1 XOR XHCICMNDTRBCYCLE ! THEN 
  ELSE 2DROP 
  THEN ;

: XHCIRINGCMD  ( -- )
   0 XHCIBASE0 @ XHCIDBOFF @ + ! ;

: XHCIRINGCTRLEP  ( slotid -- )
   XHCICONTROLEP SWAP 2 LSHIFT XHCIBASE0 @ XHCIDBOFF @ + + ! ;

: XHCIPOLL   ( -- flagTO )
   TRUE 2000 0 
   DO XHCICUREVENTRINGADDR @ XHCIEVENTTRBBUFF XHCICPTRB 
      XHCIEVENTTRBBUFF XHCITRBCOMMANDOFFS + @ 1 AND XHCICUREVENTRINGCYCLE @ = 
      IF DROP FALSE LEAVE THEN 1 SLEEP 
   LOOP DUP IF ." USB xHCI Command Interrupt wait TO (Polling) " THEN ;

: XHCICLRESPDONE  ( -- )
    XHCITRBBUFF XHCITRBSTATUSOFFS + DUP @ XHCIRESPDONE INVERT AND SWAP ! ;

: XHCICHKRESPDONE?  ( statusAddr -- flag )
    @ XHCIRESPDONE AND 0= ;

: XHCITRB?  ( -- flag )
  XHCICUREVENTRINGADDR @ XHCIEVENTTRBBUFF XHCICPTRB 
  XHCIEVENTTRBBUFF XHCITRBCOMMANDOFFS + @ 1 AND XHCICUREVENTRINGCYCLE @ = ;

: XHCICPSLOT  ( addrTRBFrom addrTRBTo -- )
    DUP >R XHCITRBCOMMANDOFFS + @ [ HEX ] 0FFFFFF [ DECIMAL ] AND 
    OVER XHCITRBCOMMANDOFFS + @ [ HEX ] FF000000 [ DECIMAL ] AND OR 
    R@ XHCITRBCOMMANDOFFS + ! 
    XHCITRBSTATUSOFFS + @ R> XHCITRBSTATUSOFFS + ! ;

: XHCIHANDLETRBTYPE  ( addrTRB -- )
  DUP XHCITRBCOMMANDOFFS + @ XHCITRBGETTYPE XHCICOMMANDCOMPLETION =
  IF
( CR ." TRB CommandCompletion ")
    DUP XHCITRBPARAMOFFS + @            ( addrTRB orgAddr )
    DUP XHCIEVENTORGTRBBUFF XHCICPTRB   ( addrTRB orgAddr )
    XHCIEVENTORGTRBBUFF XHCITRBCOMMANDOFFS + @ 
    XHCITRBGETTYPE XHCIENABLESLOT =
    IF    ( addrTRB orgAddr )
      OVER XHCIEVENTORGTRBBUFF XHCICPSLOT 
    ELSE
      OVER XHCITRBSTATUSOFFS + @ XHCIEVENTORGTRBBUFF XHCITRBSTATUSOFFS + ! 
    THEN  ( addrTRB orgAddr )
    XHCIEVENTORGTRBBUFF XHCITRBSTATUSOFFS + DUP @ XHCIRESPDONE OR SWAP ! 
    ( addrTRB orgAddr )
    XHCIEVENTORGTRBBUFF SWAP XHCICPTRB 
  THEN DROP ;

: XHCIADVANCEDQPTR  ( addr -- )
  1 3 LSHIFT OR XHCIBASE0 @ XHCIRTSOFF @ + [ HEX ] 020 [ DECIMAL ] + 
  SWAP OVER ! XHCIDOHI32 DROP ;

: XHCIHANDLERESPONSE  ( -- )
( CR ." ***XHCIHANDLERESPONSE ***")
  1 SLEEP 
  XHCICUREVENTRINGADDR @   ( lastaddr )
  XHCITRB?
( CR XHCIEVENTTRBBUFF XHCITRBSIZE dump KEY?)
  IF        ( lastaddr )
    BEGIN
( CR ." EventRingCycle is 1 ")
      XHCIEVENTTRBBUFF XHCITRBCOMMANDOFFS + @ 1 2 LSHIFT AND 0= 
      IF 
( CR ." Cmd bit2 not set ")
        XHCIEVENTTRBBUFF XHCITRBSTATUSOFFS + @ XHCITRBGETCOMPCODE
( CR DUP ." TRB code=" .)
        XHCITRBSUCCESS =
        IF 
( CR ." TRBSuccess!")
   XHCIEVENTTRBBUFF XHCIHANDLETRBTYPE THEN
      ELSE
( CR ." Mark TRB ")
        XHCIEVENTTRBBUFF XHCITRBCOMMANDOFFS + @ XHCITRBGETTYPE 
        XHCITRANSEVENT = 
        IF 
( CR ." TransEvent ")
          XHCIEVENTTRBBUFF XHCITRBSTATUSOFFS + @ XHCIRESPDONE OR 
          XHCIEVENTTRBBUFF XHCITRBPARAMOFFS + @ !
        THEN 
      THEN
      DROP XHCICUREVENTRINGADDR @  
      XHCITRBSIZE XHCICUREVENTRINGADDR +!
      XHCITRB? INVERT 
    UNTIL
  THEN 
  XHCIADVANCEDQPTR ; 

: XHCISENDCMD   ( flagRing trbAddr -- flagTO )
    XHCICMNDTRBADDR @ XHCIORGTRBADDR ! 
    XHCIACMDTRB XHCICHKCMDLINKTRB 
    IF  ( ring)
      XHCIRINGCMD XHCIPOLL IF TRUE EXIT THEN XHCIHANDLERESPONSE
      XHCIORGTRBADDR @ XHCITRBSTATUSOFFS + XHCICHKRESPDONE? 
      IF CR ." DONE-bit not set! " TRUE EXIT THEN 
      XHCIORGTRBADDR @ XHCITRBBUFF XHCICPTRB XHCICLRESPDONE FALSE
    ELSE FALSE 
    THEN ;

: XHCIGMPS  ( speed -- mps )
    CASE
      XHCISPEEDLOW   OF >R   8 R> ENDOF
      XHCISPEEDFULL  OF >R  64 R> ENDOF
      XHCISPEEDHIGH  OF >R  64 R> ENDOF
      XHCISPEEDSUPER OF >R 512 R> ENDOF
    ENDCASE ;

VARIABLE XHCIPORT
VARIABLE XHCISLOTID
VARIABLE XHCIMPS
VARIABLE XHCISPEED

: XHCICLSLOT  ( -- )
   XHCISLOTCTXBUFF XHCISLOTCTXSIZE ERASE ;

: XHCIFILLSLOT  ( -- )
   1 XHCISLOTCTXBUFF XHCISLOTCTXENTRIESOFFS + !
   XHCISPEED @ XHCISLOTCTXBUFF XHCISLOTCTXSPEEDOFFS + !
   XHCIPORT @ 1+ XHCISLOTCTXBUFF XHCISLOTCTXRHPORTNUMOFFS + !
   XHCIINTERRUPTERPRIMARY XHCISLOTCTXBUFF XHCISLOTCTXINTTARGETOFFS + !
   XHCISLOTSTATEDISABLEDENABLED XHCISLOTCTXBUFF XHCISLOTCTXSLOTSTATEOFFS + ! ;

: XHCIWRITETOSLOT  ( slotBuff offset -- )  ( i.e. from to)
    OVER ( slotBuff offset slotBuff )
    DUP  XHCISLOTCTXENTRIESOFFS + @ 27 LSHIFT 
    SWAP DUP XHCISLOTCTXHUBOFFS + C@ 26 LSHIFT 
    SWAP DUP XHCISLOTCTXMTTOFFS + C@ 25 LSHIFT 
    SWAP DUP XHCISLOTCTXSPEEDOFFS + @ 20 LSHIFT 
    SWAP XHCISLOTCTXROUTESTROFFS + @ 
    OR OR OR OR   ( slotBuff offset value )
    OVER ! CELL+  ( slotBuff offset+ )
    OVER ( slotBuff offset slotBuff )
    DUP  XHCISLOTCTXNUMPORTSOFFS + @ 24 LSHIFT 
    SWAP DUP XHCISLOTCTXRHPORTNUMOFFS + @ 16 LSHIFT 
    SWAP XHCISLOTCTXMAXEXITLATOFFS + @  
    OR OR         ( slotBuff offset value )
    OVER ! CELL+  ( slotBuff offset+ )
    OVER ( slotBuff offset slotBuff )
    DUP  XHCISLOTCTXINTTARGETOFFS + @ 22 LSHIFT 
    SWAP DUP XHCISLOTCTXTTTOFFS + @ 16 LSHIFT 
    SWAP DUP XHCISLOTCTXTTPORTNUMOFFS + @ 8 LSHIFT 
    SWAP XHCISLOTCTXTTHUBSLOTIDOFFS + @ 
    OR OR OR      ( slotBuff offset value )
    OVER ! CELL+  ( slotBuff offset+ )
    OVER   ( slotBuff offset slotBuff )
    DUP  XHCISLOTCTXSLOTSTATEOFFS + @ 27 LSHIFT 
    SWAP XHCISLOTCTXDEVICEADDROFFS + @ 
    OR     ( slotBuff offset value )
    SWAP ! DROP ;

: XHCICLEP  ( -- )
   XHCIEPCTXBUFF XHCIEPCTXSIZE ERASE ;

: XHCIWRITETOEP  ( epBuff offset -- )  ( i.e. from to)
   OVER ( epBuff offset epBuff )
   DUP  XHCIEPCTXINTERVALOFFS + @ 16 LSHIFT 
   SWAP DUP XHCIEPCTXLSAOFFS + C@ 15 LSHIFT 
   SWAP DUP XHCIEPCTXMAXPSTREAMSOFFS + @ 10 LSHIFT 
   SWAP DUP  XHCIEPCTXMULTOFFS + @ 8 LSHIFT 
   SWAP XHCIEPCTXEPSTATEOFFS + @ 
   OR OR OR OR    ( epBuff offset value )
   OVER ! CELL+   ( epBuff offset+ )
   OVER ( epBuff offset epBuff )
   DUP  XHCIEPCTXMAXPACKETSIZEOFFS + @ 16 LSHIFT 
   SWAP DUP XHCIEPCTXMAXBURSTSIZEOFFS + @ 8 LSHIFT 
   SWAP DUP XHCIEPCTXHIDOFFS + C@ 7 LSHIFT 
   SWAP DUP XHCIEPCTXEPTYPEOFFS + @ 3 LSHIFT 
   SWAP XHCIEPCTXCERROFFS + @ 1 LSHIFT  
   OR OR OR OR   ( epBuff offset value )
   OVER ! CELL+  ( epBuff offset+ )
   OVER ( epBuff offset epBuff )
   DUP  XHCIEPCTXTRDEQUEUEPTRLOOFFS + @  
   SWAP XHCIEPCTXDCSOFFS + C@  
   OR   ( epBuff offset value )
   OVER ! CELL+     ( epBuff offset+ )
   OVER ( epBuff offset epBuff )
   XHCIEPCTXTRDEQUEUEPTRHIOFFS + @ 
   OVER ! CELL+  ( epBuff offset+ )
   OVER ( epBuff offset epBuff )
   DUP  XHCIEPCTXMAXESITPAYLOADOFFS + @  
   SWAP XHCIEPCTXMAXAVERAGETRBLENOFFS + @  
   OR   ( epBuff offset value )
   SWAP ! DROP ;

: XHCIREADFROMSLOT  ( offset slotBuff -- )  ( i.e from to)
   OVER @ [ HEX ] 01F [ DECIMAL ] 27 LSHIFT AND 27 RSHIFT
   OVER XHCISLOTCTXENTRIESOFFS + !
   OVER @ [ HEX ] 01 [ DECIMAL ] 26 LSHIFT AND 26 RSHIFT
   OVER XHCISLOTCTXHUBOFFS + C!
   OVER @ [ HEX ] 01 [ DECIMAL ] 25 LSHIFT AND 25 RSHIFT
   OVER XHCISLOTCTXMTTOFFS + C!
   OVER @ [ HEX ] 0F [ DECIMAL ] 20 LSHIFT AND 20 RSHIFT
   OVER XHCISLOTCTXSPEEDOFFS + !
   OVER @ [ HEX ] 0FFFFF [ DECIMAL ] AND 
   OVER XHCISLOTCTXROUTESTROFFS + !
   SWAP CELL+ SWAP
   OVER @ [ HEX ] 0FF [ DECIMAL ] 24 LSHIFT AND 24 RSHIFT
   OVER XHCISLOTCTXNUMPORTSOFFS + !
   OVER @ [ HEX ] 0FF [ DECIMAL ] 16 LSHIFT AND 16 RSHIFT
   OVER XHCISLOTCTXRHPORTNUMOFFS + !
   OVER @ [ HEX ] 0FFFF [ DECIMAL ] AND
   OVER XHCISLOTCTXMAXEXITLATOFFS + !
   SWAP CELL+ SWAP
   OVER @ [ HEX ] 03FF [ DECIMAL ] 22 LSHIFT AND 22 RSHIFT
   OVER XHCISLOTCTXINTTARGETOFFS + !
   OVER @ [ HEX ] 03 [ DECIMAL ] 16 LSHIFT AND 16 RSHIFT
   OVER XHCISLOTCTXTTTOFFS + !
   OVER @ [ HEX ] 0FF [ DECIMAL ] 8 LSHIFT AND 8 RSHIFT
   OVER XHCISLOTCTXTTPORTNUMOFFS + !
   OVER @ [ HEX ] 0FF [ DECIMAL ] AND
   OVER XHCISLOTCTXTTHUBSLOTIDOFFS + !
   SWAP CELL+ SWAP
   OVER @ [ HEX ] 01F [ DECIMAL ] 27 LSHIFT AND 27 RSHIFT
   OVER XHCISLOTCTXSLOTSTATEOFFS + !
   OVER @ [ HEX ] 0FF [ DECIMAL ] AND
   OVER XHCISLOTCTXDEVICEADDROFFS + ! 2DROP ; 

: XHCIREADFROMEP  ( offset epBuff -- )  ( i.e. from to)
   OVER @ [ HEX ] 0FF [ DECIMAL ] 16 LSHIFT AND 16 RSHIFT
   OVER XHCIEPCTXINTERVALOFFS + !
   OVER @ [ HEX ] 01 [ DECIMAL ] 15 LSHIFT AND 15 RSHIFT
   OVER XHCIEPCTXLSAOFFS + C!
   OVER @ [ HEX ] 01F [ DECIMAL ] 10 LSHIFT AND 10 RSHIFT
   OVER XHCIEPCTXMAXPSTREAMSOFFS + !
   OVER @ [ HEX ] 03 [ DECIMAL ] 8 LSHIFT AND 8 RSHIFT
   OVER XHCIEPCTXMULTOFFS + !
   OVER @ [ HEX ] 07 [ DECIMAL ] AND
   OVER XHCIEPCTXEPSTATEOFFS + !
   SWAP CELL+ SWAP
   OVER @ [ HEX ] 0FFFF [ DECIMAL ] 16 LSHIFT AND 16 RSHIFT
   OVER XHCIEPCTXMAXPACKETSIZEOFFS + !
   OVER @ [ HEX ] 0FF [ DECIMAL ] 8 LSHIFT AND 8 RSHIFT
   OVER XHCIEPCTXMAXBURSTSIZEOFFS + !
   OVER @ [ HEX ] 01 [ DECIMAL ] 7 LSHIFT AND 7 RSHIFT
   OVER XHCIEPCTXHIDOFFS + C!
   OVER @ [ HEX ] 07 [ DECIMAL ] 3 LSHIFT AND 3 RSHIFT
   OVER XHCIEPCTXEPTYPEOFFS + !
   OVER @ [ HEX ] 03 [ DECIMAL ] 1 LSHIFT AND 1 RSHIFT
   OVER XHCIEPCTXCERROFFS + !
   SWAP CELL+ SWAP
   OVER @ [ HEX ] 0F [ DECIMAL ] INVERT AND 
   OVER XHCIEPCTXTRDEQUEUEPTRLOOFFS + !
   OVER @ [ HEX ] 01 [ DECIMAL ] AND 
   OVER XHCIEPCTXDCSOFFS + C!
   SWAP CELL+ SWAP
   OVER @  
   OVER XHCIEPCTXTRDEQUEUEPTRHIOFFS + !
   SWAP CELL+ SWAP
   OVER @ [ HEX ] 0FFFF [ DECIMAL ] 16 LSHIFT AND 16 RSHIFT
   OVER XHCIEPCTXMAXESITPAYLOADOFFS + !
   OVER @ [ HEX ] 0FFFF [ DECIMAL ] AND 
   OVER XHCIEPCTXMAXAVERAGETRBLENOFFS + ! 2DROP ; 

: XHCISETADDRESS  ( slotAddr blockIt -- retFlag )
   XHCICTXSIZE @ 5 LSHIFT 64 XHCIPAGESIZE @ XHCIALHEAP 
   ( slotAddr blockIt address )
   0 OVER ! 3 OVER CELL+ !
   ( slotAddr blockIt address )
   XHCISLOTCTXBUFF OVER XHCICTXSIZE @ + XHCIWRITETOSLOT 
   XHCIEPCTXBUFF OVER XHCICTXSIZE @ + XHCICONTROLEP XHCICTXSIZE @ * + XHCIWRITETOEP 
   ( slotAddr blockIt address )
( CR ." SlotCtxBuff:")
( DUP XHCICTXSIZE @ + XHCICTXSIZE @ dump KEY?
( CR ." EpCtxBuff:")
( DUP XHCICTXSIZE @ + XHCICONTROLEP XHCICTXSIZE @ * + XHCICTXSIZE @ dump KEY?
( CR ." InputCtxBuff:")
( DUP 4 XHCICTXSIZE @ * dump KEY?)
   >R 9 LSHIFT XHCISLOTID @ XHCITRBSETSLOT XHCIADDRESSDEVICE 
      XHCITRBSETTYPE OR OR 0 0 R> XHCITRBBUFF XHCISTRB
   ( slotAddr )
   TRUE XHCITRBBUFF XHCISENDCMD IF DROP FALSE EXIT THEN 
   XHCITRBBUFF XHCITRBSTATUSOFFS + @ XHCITRBGETCOMPCODE XHCITRBSUCCESS = 
   IF    ( slotAddr )
     DUP 
     XHCISLOTCTXBUFF2 XHCIREADFROMSLOT 
     XHCISLOTCTXBUFF2 XHCISLOTCTXSLOTSTATEOFFS + @ 
( DUP CR ." slotState=" . )
     XHCISLOTCTXBUFF XHCISLOTCTXSLOTSTATEOFFS + ! 
     XHCISLOTCTXBUFF2 XHCISLOTCTXDEVICEADDROFFS + @ 
( DUP CR ." devAddr=" . KEY?)
     XHCISLOTCTXBUFF XHCISLOTCTXDEVICEADDROFFS + ! 
     ( slotAddr )
     XHCICTXSIZE @ XHCICONTROLEP * + XHCIEPCTXBUFF2 XHCIREADFROMEP 
     XHCIEPCTXBUFF2 XHCIEPCTXEPSTATEOFFS + @ 
( DUP CR ." epState=" . )
     XHCIEPCTXBUFF XHCIEPCTXEPSTATEOFFS + ! 
     XHCIEPCTXBUFF2 XHCIEPCTXMAXPACKETSIZEOFFS + @ 
( DUP CR ." mps=" . KEY?)
     XHCIEPCTXBUFF XHCIEPCTXMAXPACKETSIZEOFFS + ! 
     TRUE
   ELSE DROP FALSE
   THEN ;

: XHCIINITEP   ( slotAddr epnum epinterval type -- )
   USBCONTROLEP <> IF DROP 2DROP EXIT THEN 
   XHCICLEP XHCITRBSPERRING XHCICRRING
( CR ." ****XHCICRING=" DUP HEX U. DECIMAL CR)
   DUP XHCICUREPRINGPTR ! XHCITRBCYCLEON XHCICUREPRINGCYCLE !
   XHCIEPCTXBUFF XHCIEPCTXTRDEQUEUEPTRLOOFFS + !
   0 XHCIEPCTXBUFF XHCIEPCTXTRDEQUEUEPTRHIOFFS + !
   XHCICUREPRINGCYCLE @ XHCIEPCTXBUFF XHCIEPCTXDCSOFFS + C!
   XHCIMPS @ XHCIEPCTXBUFF XHCIEPCTXMAXPACKETSIZEOFFS + !
   XHCIEPSTATEDISABLED XHCIEPCTXBUFF XHCIEPCTXEPSTATEOFFS + !
   XHCIEPTYPECONTROL XHCIEPCTXBUFF XHCIEPCTXEPTYPEOFFS + !
   8 XHCIEPCTXBUFF XHCIEPCTXMAXAVERAGETRBLENOFFS + !
   3 XHCIEPCTXBUFF XHCIEPCTXCERROFFS + !
   XHCIEPCTXBUFF XHCIEPCTXINTERVALOFFS + ! ( slotAddr epnum )
   XHCICTXSIZE @ * + XHCIEPCTXBUFF SWAP XHCIWRITETOEP ;

: XHCIINITSLOT  ( -- slotAddr )
   XHCICTXSIZE @ 2* 32 XHCIPAGESIZE @ XHCIALHEAP   ( slotAddr )
   DUP XHCIDCBAAPSTART @ XHCISLOTID @ 3 LSHIFT + ! ( slotAddr )
   XHCICLSLOT XHCIFILLSLOT XHCISLOTCTXBUFF OVER  ( slotAddr slotBuff slotAddr )
   XHCIWRITETOSLOT ( slotAddr ) 
   DUP XHCICONTROLEP 0 USBCONTROLEP XHCIINITEP ;

: XHCISAHEAPPTR   ( -- )
   XHCICURHEAPPTR @ XHCICURHEAPPTRSAVED ! ;

: XHCIRHEAPPTR   ( -- )
   XHCICURHEAPPTRSAVED @ XHCICURHEAPPTR ! ;

: XHCIPDIR  ( dir len -- dirCtrlr )
   0= 
   IF DROP XHCIDIRNODATA 
   ELSE  
     IF XHCIDIRIN ELSE XHCIDIROUT THEN 
   THEN ;

: XHCICHKEPLINK  ( -- )
   XHCICUREPRINGPTR @ XHCITRBCOMMANDOFFS + DUP @ DUP XHCITRBGETTYPE XHCILINK = 
  ( cmdoffsAddr cmd flag )
  IF SWAP OVER 1 INVERT AND XHCICUREPRINGCYCLE @ OR SWAP ! 
    ( cmd )
     XHCICUREPRINGPTR @ @ XHCICUREPRINGPTR !
     2 AND 0<>
     IF XHCICUREPRINGCYCLE @ 1 XOR XHCICUREPRINGCYCLE ! THEN 
  ELSE 2DROP 
  THEN ;

: XHCIINCEPRINGPTR  ( -- )
   XHCITRBSIZE XHCICUREPRINGPTR +! XHCICHKEPLINK ;

: XHCISETUPSTAGE ( packetAddr dirCtrlr -- )
   16 LSHIFT XHCISTPSTAGE XHCITRBSETTYPE 1 6 LSHIFT XHCICUREPRINGCYCLE @ OR OR OR  ( packetAddr cmd )
   8      ( packetAddr cmd status )
   ROT DUP ( cmd status packetAddr packetAddr )
   USBRECPACLENGTH + W@ 16 LSHIFT OVER USBRECPACIDX + W@ OR ( cmd status packetAddr paramHI )
   SWAP DUP USBRECPACVALUE + W@ 16 LSHIFT SWAP DUP USBRECPACREQUEST + C@ 8 LSHIFT SWAP USBRECPACTYPE + C@  OR OR 
  ( cmd status packetAddr paramHI paramLO )
   XHCITRBBUFF XHCISTRB 
( CR ." SetupStage TRB:" CR)
( XHCITRBBUFF XHCITRBSIZE dump KEY?)
  XHCITRBBUFF XHCICUREPRINGPTR @ XHCICPTRB
( CR ." SetupStage TRB [in ring]:" CR
( XHCICUREPRINGPTR @ XHCITRBSIZE dump KEY?)
 XHCIINCEPRINGPTR ;

: XHCICREM   ( mps len -- remaining )
   OVER 1- + SWAP / 1- DUP 0< IF DROP 0 THEN ;

VARIABLE XHCITRBTYPE 
VARIABLE XHCIDIRCTRLR 
VARIABLE XHCIDTSIZE 
VARIABLE XHCIDTBUFF 
VARIABLE XHCIREMAINING
VARIABLE XHCIDTBUFFORIG

: XHCIDATASTAGE  ( statusAddr bufferAddr dirCtrlr len -- )
   XHCIDTSTAGE XHCITRBTYPE ! XHCIDTSIZE ! 
   XHCIDIRCTRLR ! XHCIDTBUFF !  ( statusAddr )
   XHCIMPS @ XHCIDTSIZE @ XHCICREM XHCIREMAINING ! ( statusAddr ) 
  BEGIN
   XHCIREMAINING @ 0= IF 2 ELSE 0 THEN 
   XHCIDIRCTRLR @ 16 LSHIFT 
   XHCITRBTYPE @ XHCITRBSETTYPE 
   1 4 LSHIFT 
   XHCICUREPRINGCYCLE @ 
   OR OR OR OR          ( statusAddr cmd ) 
   XHCIREMAINING @ 17 LSHIFT 
   XHCIDTSIZE @ XHCIMPS @ < IF XHCIDTSIZE @ ELSE XHCIMPS @ THEN 
   OR                   ( statusAddr cmd status ) 
   0 XHCIDTBUFF @       ( statusAddr cmd status paramHI paramLO ) 
   XHCITRBBUFF XHCISTRB 
( CR ." DataStage TRB:" CR)
( XHCITRBBUFF XHCITRBSIZE dump KEY?)
   XHCITRBBUFF XHCICUREPRINGPTR @ XHCICPTRB 
( CR ." DataStage TRB [in ring]:" CR)
( XHCICUREPRINGPTR @ XHCITRBSIZE dump KEY?)
   XHCIMPS @ XHCIDTBUFF +!
   XHCIINCEPRINGPTR 
   XHCIMPS @ NEGATE XHCIDTSIZE +!
   -1 XHCIREMAINING +!
   XHCINORMAL XHCITRBTYPE !
   0 XHCIDIRCTRLR ! 
  XHCIDTSIZE @ 0 <= UNTIL   ( statusAddr )
   0 OVER ! >R 
   XHCIEVENTDATA XHCITRBSETTYPE  1 5 LSHIFT XHCICUREPRINGCYCLE @ OR OR
   0 0 R> XHCITRBBUFF XHCISTRB 
( CR ." DataStage EventTRB:" CR)
( XHCITRBBUFF XHCITRBSIZE dump KEY?)
   XHCITRBBUFF XHCICUREPRINGPTR @ XHCICPTRB 
( CR ." DataStage EventTRB [in ring]:" CR)
( XHCICUREPRINGPTR @ XHCITRBSIZE dump KEY?)
   XHCIINCEPRINGPTR ;

VARIABLE XHCISTATUSADDR 

: XHCIWAITFORRESPONSE   ( statusAddr -- flag )
   XHCIPOLL IF DROP TRUE EXIT THEN XHCIHANDLERESPONSE
   DUP XHCICHKRESPDONE? IF ." DONE-bit not set! " DROP FALSE EXIT THEN 
   @ XHCITRBGETCOMPCODE 
    CASE
      XHCITRBSUCCESS      OF >R TRUE R> ENDOF
      XHCISHORTPACKET     OF >R TRUE R> ENDOF
      XHCISTALLERROR      OF >R FALSE R> ENDOF
      XHCIDATABUFFERERROR OF >R FALSE R> ENDOF
      XHCIBABBLEDETECTION OF >R FALSE R> ENDOF
    ENDCASE 
    DEPTH 0= IF FALSE ." WaitForResponse: unknown error!" THEN ;

: XHCIGSTSTAGEDIR   ( len dirFlag -- dirCtrlr )
   INVERT SWAP 0= OR IF XHCIDIRINB ELSE XHCIDIROUTB THEN ;

: XHCISTATUSSTAGE   ( dirCtrlr statusAddr -- )
   SWAP 16 LSHIFT XHCISTSSTAGE XHCITRBSETTYPE 1 4 LSHIFT XHCICUREPRINGCYCLE @ OR OR OR  ( statusAddr cmd )
   0         ( statusAddr cmd status )
   0 0       ( statusAddr cmd status paramHI paramLO )
   XHCITRBBUFF XHCISTRB     ( statusAddr )
( CR ." StatusStage TRB:" CR)
( XHCITRBBUFF XHCITRBSIZE dump KEY?)
   XHCITRBBUFF XHCICUREPRINGPTR @ XHCICPTRB 
   XHCIINCEPRINGPTR 0 OVER !     ( statusAddr )
   XHCIEVENTDATA XHCITRBSETTYPE 1 5 LSHIFT XHCICUREPRINGCYCLE @ OR OR 
   ( statusAddr cmd )
   0  ( statusAddr cmd status )
   ROT 0 SWAP    ( cmd status paramHI paramLO )
   XHCITRBBUFF XHCISTRB 
( CR ." StatusStage EventTRB:" CR)
( XHCITRBBUFF XHCITRBSIZE dump KEY?)
   XHCITRBBUFF XHCICUREPRINGPTR @ XHCICPTRB 
   XHCIINCEPRINGPTR ;

: XHCICONTROLIO  ( destBuffAddr dirFlag[TRUE=IN] recpacket len -- flag )
   DUP >R OVER USBRECPACLENGTH + W!  
    ( destBuffAddr dirFlag recpacket )  ( R: len )
   SWAP DUP R@ XHCIPDIR 
    ( destBuffAddr recpacket dirFlag dirCtrlr )  ( R: len )
   SWAP >R 
    ( destBuffAddr recpacket dirCtrlr )  ( R: len dirFlag )
   XHCISETUPSTAGE      ( destBuffAddr )  ( R: len dirFlag )
   4 16 16 XHCIALHEAP DUP XHCISTATUSADDR ! 256 1 0 XHCIALHEAP 
   DUP XHCIDTBUFFORIG !
   ( destBuffAddr statusAddr bufferAddr )  ( R: len dirFlag )
   2R@ SWAP 0<> 
   IF ( destBuffAddr statusAddr bufferAddr dirFlag )  ( R: len dirFlag )
      IF XHCIDIRINB ELSE XHCIDIROUTB THEN 2R@ DROP
( destBuffAddr statusAddr bufferAddr dirCtrlr len )  ( R: len dirFlag )
      XHCIDATASTAGE                 ( destBuffAddr ) ( R: len dirFlag )
      XHCISLOTID @ XHCISACUREPRINGPTR 
      XHCISLOTID @ XHCIRINGCTRLEP  
      XHCISTATUSADDR @ XHCIWAITFORRESPONSE
      INVERT IF DROP 2R> 2DROP FALSE EXIT THEN 
   ELSE 2DROP NIP 
   THEN
   2R@ XHCIGSTSTAGEDIR                ( destBuffAddr dirCtrlr ) ( R: len dirFlag )
   XHCISTATUSADDR @ XHCISTATUSSTAGE   ( destBuffAddr ) ( R: len dirFlag )
   XHCISLOTID @ XHCISACUREPRINGPTR 
   XHCISLOTID @ XHCIRINGCTRLEP  
   XHCISTATUSADDR @ XHCIWAITFORRESPONSE
   INVERT IF DROP 2R> 2DROP FALSE EXIT THEN 
   2R> IF DUP 0<> 
         IF XHCIDTBUFFORIG @ ROT ROT CMOVE ELSE 2DROP THEN 
       ELSE 2DROP 
       THEN TRUE ;

: XHCIGDEVDESC  ( -- flag )
   DEVDESCBUFF TRUE REQDEVDESCPACKET XHCIDEVDESCSIZE XHCICONTROLIO 
   DUP INVERT IF CR ." Control transfer failed (DevDescAll)" THEN ;

VARIABLE XHCILANGID

: XHCIPRSTR  ( -- )
  XHCIBUFF DUP C@ 2- 2/ 0 DO 2+ DUP C@ EMIT LOOP ; 

: XHCISALANGID  ( -- )
   XHCIBUFF 2+ W@ XHCILANGID ! ;

: XHCIGMANUFI  ( -- n )
   DEVDESCBUFF USBDEVDESCMANUFIDX + C@ ;

: XHCIGLANGIDS?  ( -- flag )
   0 REQSTRLANGSPACKET USBRECPACIDX + W!
   0 REQSTRLANGSPACKET USBRECPACLENGTH + W!
   XHCIBUFF TRUE REQSTRLANGSPACKET 18 XHCICONTROLIO ;

: XHCIGMANUF?  ( -- flag )
     XHCILANGID @ REQSTRLANGSPACKET USBRECPACIDX + C! 
     DEVDESCBUFF USBDEVDESCMANUFIDX + C@ REQSTRLANGSPACKET USBRECPACVALUE + C! 
     XHCIBUFF TRUE REQSTRLANGSPACKET 64 XHCICONTROLIO 
; 

: XHCIGPRODI  ( -- n )
   DEVDESCBUFF USBDEVDESCPRODIDX + C@ ;

: XHCIGPROD?  ( -- flag )
   XHCILANGID @ REQSTRLANGSPACKET USBRECPACIDX + C! 
   DEVDESCBUFF USBDEVDESCPRODIDX + C@ REQSTRLANGSPACKET USBRECPACVALUE + C! 
   XHCIBUFF TRUE REQSTRLANGSPACKET 64 XHCICONTROLIO ; 

: XHCIPRNONE  ( -- )
  ." None" CR ;

( prints no space after number, unlike dot )
: XHCIPRNSP  ( n -- )
   S>D <# #S #> TYPE ;

: XHCIPRPORTDEVADDR  ( -- )
  ."  (" XHCIPORT @ XHCIPRNSP 44 EMIT SPACE 
  XHCISLOTCTXBUFF XHCISLOTCTXDEVICEADDROFFS + @ XHCIPRNSP 41 EMIT CR ;

: XHCIGSTRDESC  ( -- flag )
   XHCIGLANGIDS? INVERT 
   IF CR ." Control transfer failed (LangIDs)" FALSE EXIT THEN 
   XHCISALANGID XHCIGMANUFI 0<>
   IF 
     XHCIGMANUF? INVERT 
     IF CR ." Control transfer failed (Manufacturer)" FALSE EXIT THEN 
     XHCIPRSTR
   ELSE XHCIPRNONE 
   THEN
   ."  - "
   XHCIGPRODI 0=
   IF XHCIPRNONE FALSE EXIT THEN 
   XHCIGPROD? INVERT IF CR ." Control transfer failed (Product)" FALSE EXIT THEN 
   XHCIPRSTR XHCIPRPORTDEVADDR ;

: XHCIPRDIGS2  ( b -- )
   DUP 4 RSHIFT 0= IF 48 EMIT THEN U. ; 

: XHCIPRDEVDESC   ( -- )   ( or with DUMP !?)
   CR ." DevDesc:" CR HEX DEVDESCBUFF XHCIDEVDESCSIZE 0 DO DUP C@ XHCIPRDIGS2 1+ LOOP DECIMAL CR ;

: XHCIGDESCRIPTORS   ( port -- ) 
   DUP XHCIPORT ! XHCICPORTST XHCICLDEVDESC XHCIGSPEED XHCISPEED !
   0 XHCITRBSETSTYPE XHCIENABLESLOT XHCITRBSETTYPE OR 0 0 0 XHCITRBBUFF XHCISTRB
( CR ." sending cmd ENABLESLOT ... " KEY?)
   TRUE XHCITRBBUFF XHCISENDCMD IF DROP EXIT THEN 
( CR ." ENABLESLOT Ok " KEY?)
   XHCITRBBUFF XHCITRBCOMMANDOFFS + @ XHCITRBGETSLOT DUP 
   XHCISLOTID ! 0= IF DROP EXIT THEN 
   XHCISPEED @ XHCIGMPS XHCIMPS ! 
( CR ." sending cmd SETADDRESS ... " KEY?)
   XHCIINITSLOT 0 XHCISAHEAPPTR XHCISETADDRESS XHCIRHEAPPTR INVERT IF EXIT THEN 
( CR ." SETADDRESS Ok " KEY?)
   XHCIGDEVDESC INVERT IF EXIT THEN 
   XHCIPRDEVDESC 
   XHCIGSTRDESC INVERT IF EXIT THEN ;

: XHCISCANUSB3PORTS   ( -- )
   XHCINDP @ 0 
   DO I XHCIISUSB3PORT I XHCIISACTIVE AND 
      IF I XHCIRESETPORT IF I XHCIGDESCRIPTORS THEN THEN
   LOOP ;

: XHCISCANUSB2PORTS   ( -- )
   XHCINDP @ 0 
   DO I XHCIISUSB2PORT I XHCIISACTIVE AND 
      IF I XHCIRESETPORT IF I XHCIGDESCRIPTORS THEN THEN
   LOOP ;

: XHCIPROCESS  ( b d f -- )
   3DUP XHCIEBUSMASTER XHCIPICL 
   3DUP XHCIGBASE XHCIBASE4BITS @ 1 AND 0<> 
   IF 3DROP ." XHCI not memory mapped IO" CR EXIT THEN
   XHCIBASE4BITS @ 4 = 
   IF 3DUP XHCIGUP32BITS 0<> 
     IF 3DROP ." Base0 is 64-bits (32bit OS)" CR EXIT THEN 
   THEN
   3DUP XHCIFLADJ XHCIGVER? 
   IF 3DROP ." XHCI version < 0x95" CR EXIT THEN 
   XHCIPANTHERPOINT XHCICBASEOFF XHCIRESETCTRL? 
   IF ." Resetting the controller failed (TO)" CR EXIT THEN
   XHCICEXTCAPSREGS XHCISTOPLEGACY INVERT 
   IF ." BIOS did not release Legacy support" CR EXIT THEN 
   XHCIDOPORTS XHCIGPAGESIZE XHCIGMAXSLOTS XHCIALDCBAAPSTART 
   XHCISOPSUSBDCBAAP XHCIALSCRATCHPAD XHCICRCMDRING 
   XHCIINITUSBCRCR XHCIINITUSBCFG XHCIINITUSBDNCRTL 
   XHCIINITITERRUPTERS XHCICLSTATUS 
   XHCICLCUREPRINGPTRARR XHCISTARTSCHEDULE 100 SLEEP 
   XHCISCANUSB3PORTS XHCISCANUSB2PORTS ;

: XHCIENUM  ( -- flag )
   PCIDETXHCI  ( -- b d f TRUE )   ( -- FALSE )
   IF XHCIHEAPINIT XHCICURHEAPPTR !
      [ HEX ] 0FF [ DECIMAL ] XHCIINITEDMSD !
      CR ." Found XHCI controller " HEX >R >R DUP . ." :" R> DUP . 
      ." :" R> DUP . DECIMAL CR ." String (Port, DeviceAddress)" CR 
      XHCIPROCESS XHCICURHEAPPTR @ XHCICURHEAPPTRAFTERENUM ! TRUE
   ELSE FALSE
   THEN ;

VARIABLE XHCIDEVADDR 
VARIABLE XHCIINITEDMSD
VARIABLE XHCISLOTADDR 

: XHCIGDEVDATA  ( devaddr -- flag )
  XHCIDCBAAPSTART @ 0 
  BEGIN
    1+ >R
	8 + DUP @ 0= IF R> 3DROP FALSE EXIT THEN
    DUP @ DUP XHCISLOTADDR !
    XHCISLOTCTXBUFF XHCIREADFROMSLOT 
    OVER XHCISLOTCTXBUFF XHCISLOTCTXDEVICEADDROFFS + @ = R> SWAP 
  UNTIL
  XHCISLOTCTXBUFF XHCISLOTCTXSLOTSTATEOFFS + @ XHCISLOTSTATEADDRESSED =
  IF 
    XHCISLOTID !
    XHCISLOTCTXBUFF XHCISLOTCTXSPEEDOFFS + @ XHCIGMPS XHCIMPS !
  ELSE DROP FALSE 
  THEN 2DROP ;

: XHCIGBOSDESC  ( -- flag )
   XHCIBUFF TRUE REQBOSPACKET XHCIBOSDESCSIZE XHCICONTROLIO 
   DUP INVERT IF CR ." Control transfer failed (BOS)" THEN ;

: XHCIPRBOSDESC   ( -- )   ( or with DUMP !?)
   CR ." BOSDesc:" CR HEX XHCIBUFF XHCIBOSDESCSIZE 0 DO DUP C@ XHCIPRDIGS2 1+ LOOP DECIMAL CR ;

: XHCIGCONFIGDESC  ( len -- flag )
   >R XHCIBUFF TRUE REQCONFIGPACKET R> XHCICONTROLIO 
   DUP INVERT IF CR ." Control transfer failed (Config)" THEN ;

: XHCIPRCONFIGDESC   ( -- )   ( or with DUMP !?)
   CR ." ConfigDesc:" CR HEX XHCIBUFF DUP 2+ W@ 0 DO DUP C@ XHCIPRDIGS2 1+ LOOP DECIMAL CR ;

VARIABLE XHCIBULKINEPT 
VARIABLE XHCIBULKOUTEPT 

: XHCISAENDPTNUM  ( endptByte -- endptnum )
  DUP 128 AND 0<> IF 15 AND DUP XHCIBULKINEPT ! ELSE 15 AND DUP XHCIBULKOUTEPT ! THEN ;

VARIABLE XHCIBULKINMPS 
VARIABLE XHCIBULKOUTMPS 

: XHCISAENDPTMPS  ( endptmps endptnum -- )
  1 = IF XHCIBULKINMPS ! ELSE XHCIBULKOUTMPS ! THEN ;

: XHCISAENDPTS ( -- flag )
  XHCIBUFF DUP C@ + DUP 4 + C@ 1 <= 
  IF DROP FALSE CR ." Not enough endpoints" EXIT THEN
  DUP C@ + DUP 2+ C@ XHCISAENDPTNUM OVER 4 + W@ SWAP XHCISAENDPTMPS 
  DUP C@ + DUP 1+ C@ [ HEX ] 030 [ DECIMAL ] IF DUP C@ + THEN 
  DUP 2+ C@ XHCISAENDPTNUM SWAP 4 + W@ SWAP XHCISAENDPTMPS TRUE ;

: XHCIMSD?   ( -- flag )
  XHCIBUFF 4 + C@ 0<> 
  IF XHCIBUFF DUP C@ + 5 + C@ 8 = ELSE FALSE THEN ;

: XHCIGLUN  ( -- flag )
   XHCIBUFF TRUE REQLUNPACKET 1 XHCICONTROLIO 
   DUP INVERT IF CR ." Control transfer failed (LUN)" THEN ;

VARIABLE XHCIMAXLUN 

: XHCISALUN  ( -- )
  XHCIBUFF C@ DUP 255 = IF DROP 0 THEN XHCIMAXLUN ! ; 

: XHCIPRLUN  ( -- )
  CR ." MaxLun: " XHCIMAXLUN ? ;

( idx=0: print nothing)
( idx=1: print device-descriptor only)
( idx=2: print all the descriptors)
( If device is a Mass-Storage one (0x08), then prints MaxLun)
: XHCIDEVINFO  ( devaddr idx -- flag )
   255 XHCIINITEDMSD !
   SWAP DUP XHCIDEVADDR !
   XHCIGDEVDATA INVERT IF DROP EXIT THEN 
   XHCISLOTID @ XHCIGCUREPRINGPTR 
   DUP 0<> IF CR ." Getting Device-descriptor ..." THEN 
   XHCIGDEVDESC INVERT IF DROP EXIT THEN 
   DUP 0<> IF XHCIPRDEVDESC THEN 
   XHCIMPS @ 512 U>=
   IF  ( BOS)
     DUP 2 = IF CR ." Getting BOS-descriptor ..." THEN 
     XHCIGBOSDESC INVERT IF DROP EXIT THEN 
     DUP 2 = IF XHCIPRBOSDESC THEN 
   THEN   
   DUP 2 = IF CR ." Getting Configuration-descriptor ..." THEN 
   XHCICONFIGDESCSIZE XHCIGCONFIGDESC INVERT IF DROP EXIT THEN 
   XHCIBUFF 2+ W@ DUP 64 U>
   IF XHCIGCONFIGDESC INVERT IF DROP EXIT THEN ELSE DROP THEN
   DUP 2 = IF XHCIPRCONFIGDESC THEN 
   XHCISAENDPTS INVERT IF DROP EXIT THEN 
   XHCIMSD?
   DUP 2 = IF CR ." Getting LUN ..." THEN 
   XHCIGLUN INVERT IF DROP EXIT THEN 
   XHCISALUN 2 = IF XHCIPRLUN THEN ;


